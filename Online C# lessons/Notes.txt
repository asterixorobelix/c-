Microsoft
https://msdn.microsoft.com/en-us/library/cs8hbt1w(v=vs.90).aspx
https://code.msdn.microsoft.com/Visual-Studio-2010-SDK-ddfe1372

c# Tutorial
http://csharp.net-tutorials.com/classes/introduction/

A variable can be compared to a storage room, and is essential for the programmer. In C#, a variable is declared like this: 
<data type> <name>; 

An example could look like this: 
string name; 

That's the most basic version. Usually, you wish to assign a visibility to the variable, and perhaps assign a value to it at the same time. It can be done like this: 
<visibility> <data type> <name> = <value>; 

And with an example:
private string name = "John Doe";

A function allows you to encapsulate a piece of code and call it from other parts of your code. You may very soon run into a situation where you need to repeat a piece of code, from multiple places, and this is where functions come in. In C#, they are basically declared like this:
<visibility> <return type> <name>(<parameters>)
{
	<function code>
}

The out modifier
The out modifier works pretty much like the ref modifier. They both ensure that the parameter is passed by reference instead of by value, but they do come with two important differences: A value passed to a ref modifier has to be initialized before calling the method - this is not true for the out modifier, where you can use un-initialized values. On the other hand, you can't leave a function call with an out parameter, without assigning a value to it. Since you can pass in un-initialized values as an out parameter, you are not able to actually use an out parameter inside a function - you can only assign a new value to it. 

The params modifier
So far, all of our functions have accepted a fixed amount of parameters. However, in some cases, you might need a function which takes an arbitrary number of parameters. By using the params keyword, you can specify a method parameter which takes a variable number of arguments.
You can send a comma-separated list of arguments of the type specified in the parameter declaration or an array of arguments of the specified type. You also can send no arguments. If you send no arguments, the length of the params list is zero.

Properties allow you to control the accessibility of a classes variables, and is the recommended way to access variables from the outside in an object oriented programming language like C#.
A property is much like a combination of a variable and a method - it can't take any parameters, but you are able to process the value before it's assigned to our returned. A property consists of 2 parts, a get and a set method.
Constructors are special methods, used when instantiating a class. A constructor can never return anything, which is why you don't have to define a return type for it. A normal method is defined like this:

public string Describe()
A constructor can be defined like this:
public Car()
A constructor can be overloaded as well, meaning we can have several constructors, with the same name, but different parameters. 

Encapsulation
Encapsulation,also known as data hiding, is an important object-oriented programming concept. It is the act of concealing the functionality of a class so that the internal operations are hidden, and irrelevant, to the programmer. With correct encapsulation, the developer does not need to understand how the class actually operates in order to communicate with it via its publicly available methods and properties; known as its public interface.
Encapsulation is essential to creating maintainable object-oriented programs. When the interaction with an object uses only the publicly available interface of methods and properties, the class of the object becomes a correctly isolated unit. This unit can then be replaced independently to fix bugs, to change internal behaviour or to improve functionality or performance.
In the real world, this is similar to replacing a lightbulb. As long as we choose the correct bulb size and connection (the public interface), it will work. It does not matter if the manufacturer is different or the internal workings of the bulb differ from the original. It may even offer an improvement in brightness!

Public methods are part of the class's public interface, ie. these are the methods that can be called by other objects.
To provide for encapsulation, where the internal functionality of the class is hidden, some methods will be defined as private. Methods with a private protection level are completely invisible to external classes.
To define a method as private, the private keyword can be used as a prefix to the method. Alternatively, using no prefix at all implies that the method is private by default.

To define a class-scoped variable, the declaration is made within the class's code block but outside of any methods or properties. Although not required, it is useful to precede the variable declaration with the private keyword to make the code clear and easy to read. 

A final keyword to consider is "this". The "this" keyword can be used within a class's code to refer to the current instantiated object. 
The "this" keyword does have another use. If a method is being called and the current object is to be passed to that method, setting a parameter to "this" achieves the desired result. 

In order to set properties, an object is instantiated and the property values are assigned individually. This gives the desired result but is not ideal as it is possible for a property to be forgotten and left undefined, possibly leaving the entire object in an invalid state. This problem is solved with the use of constructors.
A constructor is a special class member that is executed when a new object is created. The constructor's job is to initialise all of the public and private state of the new object and to perform any other tasks that the programmer requires before the object is used.
The syntax to add a new constructor to a class is similar to that of adding a method. However, the constructor has the same name as the class and does not include a return type.

Sometimes you will want to create behaviour that is not linked to any individual object, instead being available to all instances and to objects of other classes. This is where static members become useful.
Static methods are useful when creating functions that are not reliant on any instance of a class. In order to call a static method, the class name and method name are used, separated by a full stop (or period). 
It is important to understand that static methods may not directly use non-static members. It is invalid for one static method to directly call a non-static method or property without first instantiating an object. Similarly, private variables that are not marked as static cannot be utilised by a static method. The reverse of this is not true of course, as a non-static member can call a static method.
A static constructor is used to initialise the static state of a class when it is first used. This is similar to a standard constructor with some exceptions. A static constructor is always declared as private and as such may not be directly called by a program. A static constructor therefore has no facility to add parameters. It is also not possible to include a static destructor.
To add a static constructor, create a private constructor with the static keyword as a prefix. 

Polymorphism permits objects to behave in different ways according to the manner in which they are used. One part of polymorphism is the ability for a method to behave differently according to the types and number of parameters that are passed to it. This is achieved through method overloading.
In order to use overloaded methods, the signature must differ for each method declaration. This means that every overloaded method in a class must have either a different number of parameters or a different set of argument data types to every other method with the same name. However, the return type of the method is not included in this signature. This means that two methods that differ only in return type cannot be created in the same class.
Where parameters are passed by reference, they are considered to be different to those passed by value. This means that it is valid to have an overloaded method with the same set of parameter data types if one version passes parameters by value and the other by reference.

Creating an overloaded constructor is as simple as adding overloaded methods. To add a second constructor, we simply declare another variation with a different signature. Overloaded constructors can be used to instantiate objects in exactly the same manner as for classes with a single constructor. During compilation of the code, the compiler compares the signature used for the new object to those available in the class. If there is a perfect match, the corresponding constructor is used. Where there is no signature with the correct parameters, the compiler will look for a constructor that can be used with implicit casting. If no such constructor exists, a compiler error occurs.
Constructors can be very complex, performing many initialisation and validation functions for new objects. This can easily lead to large constructors with functionality that is repeated in each overloaded version. This, in turn, can lead to maintenance problems with the code when changes to construction logic are required. This can be minimised by having the constructor call methods within the class to perform common tasks. Another option is to allow code reuse by having the constructors call each other during object instantiation.
To create a constructor that calls an existing constructor, a special syntax is used. The constructor is declared as usual and then a colon character (:) is appended. After the colon the this keyword and the parameter list of the called constructor is provided. Each parameter specified in the call must match one of those in the new constructor or be a literal value.

public Constructor(parameters-1) : this(parameters-2) { }

When the new constructor is utilised, the constructor indicated in the this command is executed first, then the code within the new constructor's code block is run. It is possible that the code block is empty where only a transformation of signature is required. In this case, only the original constructor is executed with the specified parameters.

What is a Delegate?
A delegate is a special kind of object that holds a reference to a method. The delegate can be called as if it were any other method. However, when called, the underlying referenced method is executed. This simple layer of abstraction is useful because unlike a direct call, the method being used does not need to be known when writing the code. The reference is created at run-time and may be changed repeatedly throughout the life of the executing program.
NB: If you have previously used C++ function pointers then you will see many similarities between these and delegates. Unlike function pointers, C# delegates are object-oriented, secure and type-safe.

Namespaces allow classes, structures and other items to be grouped and organised and remove the possibility of class-naming conflicts.
The .NET framework provides a huge number of base classes, data types, algorithms, etc. If every one of these items had to be declared with a unique name, the naming task would be equally large and would leave very few good names available for the .NET developer.
To ensure that naming conflicts do not occur, either within the .NET framework or in your own programs, namespaces are used. A namespace simply provides a named group of classes, structures, enumerations, delegates, interfaces and other namespaces. Within the namespace, all declared items must be uniquely named. However, the same name may be duplicated in different namespaces. This means that if you decide to create a mathematics library you will be able to call it 'Math' even though Microsoft have also provided a Math library.
All definitions are created in a namespace, even if one is not explicitly declared. The .NET framework provides the default namespace, which is used automatically for any code that is written outside of any namespace declaration. This can be useful for short programs but has the drawback that all of the benefits that namespaces bring to organising your code are lost.
Namespaces are declared using the namespace keyword. The basic syntax for creating a namespace is very simple, requiring only a name for the new grouping and a code block surrounded by braces:
namespace namespace-name {}

Namespace declarations are additive. This means that the same namespace definition can be included in your code in multiple locations. Where two or more matching declarations are made, the contents of the two namespaces are combined into one. This is especially useful when an application can be deployed in different versions as the optional code can be placed in separate code files. The files can then be "swapped in" to create the various build configurations.
If you were required to prefix every use of every class, structure, enumeration, etc. with the name of the namespace that contained it, your code would become unwieldy. To avoid this the using directive can be used. You will already have seen this directive in action at the start of almost every code file that you have created.
The using directive tells the compiler that a namespace is in use by the code. When the compiler finds a class name that is not recognised in the current namespace, it instead checks each namespace defined in a using directive to see if the item exists there. This means that the fully qualified name for items within such a referenced namespace need not be used.
However, where two using directives are included and each referenced namespace contains a matching class name, a name conflict is created.
Now that both of the additional namespaces are referenced the compiler does not know which Test class to use when creating the object in the Main method. 
This problem could be resolved by simply providing the fully qualified name when using the Test classes. However, namespace names can be very long and this presents the original problem of making the code more difficult to read. Instead, the using directive can be used to create an alias. This allows a shorter name to be linked to a namespace and to be used instead of the namespace to qualify the class.
In addition, namespaces may be created within other namespaces to create a nested categorisation. This allows for deep tree structures to be created and for great control over the organisation of code modules.
Consider the following nested namespace declarations:
namespace Parent
{
    namespace Child
    {
        namespace Grandchild
        {
            class Test
            {
                public void ShowMessage()
                {
                    Console.WriteLine("This is a nested namespace!");
                }
            }
        }
    }
}
In this situation there are three levels of namespace with each declared inside its parent. The "Test" class is declared within the third level of nesting. To access this class using its fully qualified name, all three namespaces must be specified with each prefixing its child and separated using a full stop. The fully qualified name for the Test class is therefore "Parent.Child.Grandchild.Test".
As with single layer namespaces, a using directive can be added to remove the requirement to use the fully qualified name. In this case, the using directive would be:
using Parent.Child.Grandchild;