c# Books
Rob Miles
Andrew Troelsen
Jamie Chan
John Sharp

c# practicing websites
https://www.codewars.com/
http://www.programmr.com/
https://www.codingame.com/start
https://codefights.com/

c# learning websites

https://www.sololearn.com/Course/CSharp/
https://code.tutsplus.com/courses/30-days-to-learn-c (must purchase courses)
https://www.tutorialspoint.com/csharp/

ASP.NET MVC websites
Pluralsight
Lynda
DevUniversity
https://www.youtube.com/user/bobtabor
http://www.tutorialsteacher.com/mvc/asp.net-mvc-tutorials
https://www.tutorialspoint.com/asp.net_mvc/

XAML
https://www.tutorialspoint.com/xaml/index.htm
http://www.wpf-tutorial.com/xaml/basic-xaml/
https://www.pluralsight.com/courses/enterprise-wpf-xaml-csharp-from-scratch

c#

Terminology

.net framework

A framework is a collection of APIs and shared library of code. A framework is code which the programmer can use without writing it explicitly in their code.
.NET is both a library of code called the Framework class library (FCL) and a runtime environment (virtual machine). The framework creates a virtual machine, in which the programs run.
The virtual machine handles things like memory management and security. The virtual machine also allows the user experience to be the same across supported languages, such as c++ and c#.
Mono is a version of .NET for linux
A library is equivalent to an exe file, but with the extension .dll; it has no entry point, but is referenced by other programs.

ASP.NET

ASP = Active Server Pages. ASP.NET is a virtual machine hosted on a server. It is a server side web technology. Allows you to develop dynamic websites and web apps.
ASP supports any .NET supported language. ASP works on top of the HTML protocol, it is also a part of the .NET framework, providing you with access to its infrastructure.
ASP has three frameworks for creating web applications: web forms, MVC and web pages.

MVC

ASP.NET MVC targets developers focussing on test-driven development. MVC = Model,View,Controllers. Splitting up a website/app in this way allows seperate teams to work on each aspect.
Each component can then also be tested independently.
Model = classes for data and logic
View = templates for HTML
Controllers = classes for browser requests and retrieving data

MVC uses different controller classes and their different action methods, depending on the incoming URL. The first part of the URL specifies the controller class to execute. So, /HelloWorld maps to the HelloWorld Controller class.
The second part of the URL specifies the method to execute. So, /HelloWorld/Index invokes the Index method of the HelloWorld Controller class. Methods which are named Index are automatically the default. Defaults are called if not explicitly specified.
http://localhost:1234/HelloWorld/Welcome

The controller handles the logic of the application and acts as the coordinator between the view and the model. The controller receives input from the user via the View. The Controller also receives relevant and processed data from the model. The controller then sends these results to the View.

When a user types a URL into the browser address bar, this calls a method, which belongs to a class. This is the Controller. 
The Model is packaged data to present to the user and which the user interacts with. It is a class. It is the data which the controller passes to the View.
The View takes the data and turns it into HTML. It is a template for the data, without any logic.

Controllers are classes with methods, models are classes without methods.

Generally, MVC is not the whole app. Other features will often be added.

Test Driven Development (TDD)

This is a software development process which relies on the repetition of extremely short development cycles. A user requirement is turned into a specific test case and then software is developed to pass that test only.
Nothing additional is added to the software, a minimum of code should be written in order to pass the test. If the software is proven to pass the test, the cycle begins again. These cycles should repeat as quickly as possible.
TDD is different to unit testing, in which the code is tested after it is written. Writing the test before the code makes you focus on the user requirement before coding.
TDD can reduce the debugging effort and makes documentation better. If used with version control software, reverting to the last successful code is often easier than debugging the current code.
This system also allows one to focus on a small chunk, rather than being overwhelmed by the whole task. Also, because all the code in the final project has been through at least one test, you have more confidence in the final solution.
The method also makes you think of software as a group of much smaller units of code, allowing one to write more modularized, flexible and extensible code.
The final result is a bunch of small code units, written and tested independently and integrated later.

Entity Framework (EF)

This is an opensource object relational mapping framework and has been added to the .NET framework. It enables one to work with data, such as customer addresses, without being concerned with where and how the data is stored.
A higher level of abstraction creates a virtual database, even if the data is stored with different languages and on different types of computer hardware.
You basically convert the data into a simpler form for storage and then convert it back, in a standardised manner upon retrieval. The Entity Framework (EF) supports a development paradigm called Code First. Code First allows you to create model objects by writing simple classes.
You can then have the database created on the fly from your classes, which enables a very clean and rapid development workflow.
There are three ways you can work with data models and databases in the Entity Framework: Database First, Model First, and Code First.
If you already have a database, the Entity Framework designer built into Visual Studio can automatically generate a data model that consists of classes and properties that correspond to existing database objects such as tables and columns. 
 If you don't have a database, you can code your own classes and properties that correspond to tables and columns. If you do have a database, Entity Framework tools can generate the classes and properties that correspond to existing tables and columns. 

Web API

An API is a set of clearly defined systems of communication between software components. This makes it easier to use the technology within the API, without a knowing specifics about how the goal is achieved.
The implementation is hidden away and only exposes the parts required by the user to interface with the code. The API describes and prescribes the expected behaviour.

Examples of web APIs are HTTP or JSON. The ASP.NET web API is a framework for building HTTP services. It is similar to ASP.NET MVC, but it is not part of the MVC framework.
The web API allows you to develop one website which is compatible with multiple browsers and mobile devices.

Windows Presentation Foundation (WPF)

WPF is the category of features in the .NET Framework which deals with the visual presentation of Windows-based applications and Web browser-based client applications.
WPF uses XAML for constructing visually stunning user interfaces (UI) in markup instead of in a programming language such as C#. 
WPF unifies how Windows creates, displays, and manipulates documents, media, and user interface (UI).

XAML - pronounced "Zammel"

This is a markup language, similar to HTML. Extensible Application Markup Language = XAML
You can create elaborate user interfaces, entirely in XAML by defining elements such as controls, text, images, shapes, animation, and more.
eg <Ellipse Fill="Gray" Height = "100"/>
When represented as text, XAML files are XML files which generally have the .xaml extension.
The XAML language defines concepts of its own, but these concepts work within the XML language and markup form.
It can be combined with c# to create logic.
XAML can be used in different platforms such as WPF (Windows Presentation Foundation), Silverlight, Mobile Development, and Windows Store App. It can be used across different .Net framework and CLR (common language runtime) versions.
In the earlier GUI frameworks, there was no real separation between how an application looks like and how it behaves. Both the GUI and its behavior were created in the same language, e.g. C# or VB.net, which would require more effort from the developer to implement both the UI and the behavior associated with it.

Visual studio

Microsoft Visual Studio is an integrated development environment (IDE) from Microsoft. 
It is used to develop computer programs for Microsoft Windows, as well as web sites, web apps, web services and mobile apps.
Visual Studio includes a code editor, with auto code completion and an integrated debugger . Other built-in tools include templates for building GUI and web apps.
As code is being written, Visual Studio compiles it in the background in order to provide feedback about syntax and compilation errors, which are flagged with a red wavy underline.

Agile software development

Agile software development describes a set of principles for software development under which requirements and solutions evolve through the collaborative effort of self-organizing cross-functional teams.
It advocates adaptive planning, evolutionary development, early delivery, and continuous improvement, and it encourages rapid and flexible response to change.
The main principles:
Individuals and interactions
Self-organization and motivation are important, as are interactions like co-location and pair programming.
Working software
Working software is more useful and welcome than just presenting documents to clients in meetings.
Customer collaboration
Requirements cannot be fully collected at the beginning of the software development cycle, therefore continuous customer or stakeholder involvement is very important.
Responding to change
Agile software development methods are focused on quick responses to change and continuous development.

Iterative, incremental and evolutionary
Most agile development methods break product development work into small increments that minimize the amount of up-front planning and design. 
Iterations are short time frames (timeboxes) which typically last from one to four weeks. Each iteration involves a cross-functional team working in all functions: planning, analysis, design, coding, unit testing, and acceptance testing. 
At the end of the iteration a working product is demonstrated to stakeholders. This minimizes overall risk and allows the product to adapt to changes quickly.
An iteration might not add enough functionality to warrant a market release, but the goal is to have an available release (with minimal bugs) at the end of each iteration. Multiple iterations might be required to release a product or new features.

Efficient and face-to-face communication
Very short feedback loop and adaptation cycle

Popular methods include:
Lean software development
Kanban
Rapid application development (RAD)
Scrum
Scrumban

Lean Software Development is considered an Agile Software Development Method.
Lean development can be summarized by seven principles, very close in concept to lean manufacturing principles:
Eliminate waste
Amplify learning
Decide as late as possible
Deliver as fast as possible
Empower the team
Build integrity in
See the whole

Razor is a markup syntax that lets you embed server-based code into web pages using C#. It is not a programming language. It is a server side markup language.
Razor has no ties to ASP.NET MVC because Razor is a general-purpose templating engine. You can use it anywhere to generate output like HTML. It's just that ASP.NET MVC has implemented a view engine that allows us to use Razor inside of an MVC application to produce HTML.
You will have a template file that's a mix of some literal text and some blocks of code. You combine that template with some data or a specific model where the template specifies where the data is supposed to appear, and then you execute the template to generate your output.
With Razor syntax you can begin a bit of C# code by using the ‘@’ sign and the Razor parse will automatically switch into parsing this statement, for each statement, as a bit of C# code.
The @ character can start inline expressions, single statement blocks and multi-statement blocks.
Basically, the @ is just where c# code has been written in a file which contains html and is a .cshtml extension.
Rendering HTML is done with the Razor view engine. To use this system, the controller action produces a ViewResult object, which can also carry the name of the specific razor view which the controller action wants to use. It can also carry a model object which it will consume.
So, it can take something like a restaurant name held in a database somewhere and place that into html. All Razor views have the extension .cshtml.
You start writing c# in a Razor View with an @. Razor then evaluates the c# expression and puts the result into the HTML.
MVC takes the view and compiles it into a Class, which will have properties and members available. 
eg @Model.Name //This gives you access to the name of the Restuarant placed into the Model object.
You can supply Razor views with directives, which sets the type of the Model property in the RazorView.
eg @model OdeToFood.ViewModels.HomePageViewModel 

@*multiline comment in Razor*@

The ViewBag syntax allows you to transfer temporary data from the controller to the view.

MVC
Controller Actions are the public methods of the controller classes. The public keyword exposes members of a class to other classes. If a member is declared private, another class cannot access it.
The Controller invokes classes based on the incoming http request which goes through the router middleware; converting the URL into arguments for the classes.
The directory structure matches the namespace structure in ASP. So, if you move a file from the folder called models, to the folder called entities, the namespace will change from: namespace OdeToFood.Models to: namespace OdeToFood.Entities
This means that some of the using statements will have to change as well.

Middleware
Middleware is basically a piece of code which may be used to process an http request. Middleware functions are usually chained together and it’s up to them to decide whether to invoke the next one in the chain.
When a request comes into the application, the first middleware function is executed. Let’s say it contains some logging logic. It logs request properties and invokes the next middleware in the chain. The next one deal with authentication. It may check if a particular cookie is present in the request and either pass the control to the next middleware or set a 401 HTTP code and return the response. Before the response is actually returned, it is passed through all the functions that are earlier in the chain (the logger in our case).
In ASP.NET Core middleware functions are defined in the Configure method of the Startup class. This method is executed automatically by the framework when your application starts.
In this method the framework provides the IApplicationBuilder instance containing several useful properties and methods:

IApplicationBuilder Use(Func<RequestDelegate, RequestDelegate> middleware)
This is the most important method for us at the moment. It registers a new middleware function adding it to the end of the chain.
IServiceProvider ApplicationServices { get; set; }
Inversion of control container. We’ll use this object to create instances of classes required by the middleware.
IDictionary<string, object> Properties { get; set; }
Initially this dictionary contains just the IServerInformation and IServiceProvider instances (which are the same objects returned by the properties described above). It can be used to store additional application-wide settings.
IApplicationBuilder New()
Creates a new instance of IApplicationBuilder. Currently I can’t think of a use case for it.
RequestDelegate Build()
Chains the registered middlewares and returns them as a single RequestDelegate.
http://blog.dudak.me/2014/custom-middleware-with-dependency-injection-in-asp-net-core/

The ConfigureServices method is where classes are registered for IoC. The ConfigureServices method is executed by the framework before Configure, so that all the dependencies are ready to be used in middleware.

Routing
There are two types of routing, Convention based routing and Attribute based routing. Convention based routing is defined in the startup.cs file by default. Attribute based routing is defined in the Controller files.

Convention based routing - templates tell MVC how to look at at a URL and obtain an action name (public method in a class) and a controller name (which is a class).
Attribute based routing - c# attributes which have been placed on the controller classes and methods of those classes provide metadata to ASP.NET which determines which class and method to call.
Convetion and attribute routing can be combined. Attribute based routing generally works best for special case routes or actions which need some extra parameters.

IActionResult
It is common to derive your classes from a base class provided by the MVC framework. This gives you access to inherited methods. These derived classes typically use the IActionResult interface. An IActionResult is a formal way to encapsulate the decision of the controller. eg: It has decided to return content, but it could also return HTML,JSON or XML.
The controller decides what to do next and then the MVC framework works out how to render it. This higher level of abstraction is preferred over the controller deciding what to do and then doing the action as well. eg: when middleware or some other component pushes HTML out.

ASP.NET core 
This is a web framework

When a system is designed to use DI, with many classes requesting their dependencies via their constructor (or properties), it's helpful to have a class dedicated to creating these classes with their associated dependencies. These classes are referred to as containers, or more specifically, Inversion of Control (IoC) containers or Dependency Injection (DI) containers. A container is essentially a factory which is responsible for providing instances of types that are requested from it.
ASP.NET Core includes a simple built-in container (represented by the IServiceProvider interface) which supports constructor injection by default, and ASP.NET makes certain services available through DI. ASP.NET's container refers to the types it manages as services.  

Inversion of control
Inversion of Control (IoC) is often explained in comparison to procedural programming. In procedural programming, code x which uses other code y, knows exactly which method, belonging to which class, is being used. 
IoC means that objects do not create other objects on which they rely to do their work. Instead, they get the objects which they need from an outside source, in the case of .NET, this is the services class.
Inversion of control container: http://joelabrahamsson.com/inversion-of-control-an-introduction-with-examples-in-net/
The Dependency Inversion Principle, states that "high level modules should not depend on low level modules; both should depend on abstractions." Instead of referencing specific implementations, classes request abstractions (typically interfaces) which are provided to them when the class is constructed. 

Dependency injection
Dependency Injection (DI) means that IoC is done without the objects' intervention, usually by a .NET Framework component which passes constructor parameters and sets properties.
What is a dependency? When we use another object to perform a certain task, we are creating a dependency on that object. That object might use other objects, too, so you are implicitly depending on those other objects, and they too might depend on other objects to do their work, and so on.
Most often, classes will declare their dependencies via their constructor, this approach is known as "constructor injection".

What Is the Difference Between an Entity and a Service?
Entity - An object which has a unique identity in the domain model of the application
Service - An object which performs a distinct part of the application functionality

c# lambda expressions
A lambda expression describes a pattern. From mathematics, the lambda calculus describes the world in patterns. In C# a lambda is a function which uses clear and short syntax, for example: x => x + 1
To the left, are the arguments. The "x" is just a name—we can use any valid name. The result is on the right (x+1). You can pass lambda expressions as arguments, for sorting or for searching.
The => operator can be read as "goes to." It is always used when declaring a lambda expression. We can achieve the same thing with regular, non-lambda methods. But they make a language easier to use, more "expressive."
Lambda expressions are particularly helpful for writing LINQ query expressions. In order to create a lambda expression, you specify input parameters (if any) on the left side of the lambda operator =>, and you put the expression or statement block on the other side. For example, the lambda expression x => x * x specifies a parameter that’s named x and returns the value of x squared.

Anonymous functions
These are functions which have no names.

SOLID Design principles
http://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/

SOLID is basically 5 principles, which will help to create a good software architecture. SOLID is an acronym of the following:

S is single responsibility principle (SRP)
O stands for open closed principle (OCP)
L Liskov substitution principle (LSP)
I interface segregation principle (ISP)
D Dependency injection principle (DIP)

Single responsibility principle (SRP)
According to SRP, one class should take responsibility for only one thing, so that changes in one class do not affect other classes. Every software module should have only one reason for a change to be made to it.
It does not mean that your classes should only contain one method or property. There may be many members as long as they relate to the single responsibility.

Open closed principle (OCP)
This means that a Class should be open for extension but closed for modification. In order to do this, you use inheritance rather than things like if statements in classes.
Here "Open for extension" means, we need to design our module/class in such a way that the new functionality can be added only when new requirements are generated. "Closed for modification" means we have already developed a class and it has gone through unit testing. 
Generally, we can do this by referring to abstractions for dependencies, such as interfaces or abstract classes, rather than using concrete classes. Such interfaces can be fixed once developed so that the classes which depend upon them can rely upon unchanging abstractions.
Functionality can be added by creating new classes which implement the interfaces.

Liskov substitution principle (LSP)
This principle states that a Child class should not break a Parent class’s type definition and behavior. The Liskov Substitution Principle (LSP) states that "you should be able to use any derived class instead of a parent class and have it behave in the same manner without modification".
It ensures that a derived class does not affect the behavior of the parent class, in other words that a derived class must be substitutable for its base class. For example: A father who is a doctor whereas his son wants to become a cricketer. In this case, the son can't replace his father even though they both belong to the same family hierarchy.

Interface segregation principle (ISP)
This principle states that a class should not be forced to use an interface which is irrelevant to it. Instead of one fat interface many small interfaces are preferred based on groups of methods, each one serving one sub module.
An interface should be more closely related to the code which uses it than code which implements it. So the methods on the interface are defined by the methods which the client code needs, rather than the methods which the class implements. So, clients should not be forced to depend upon interfaces which they don't use.
The larger the interface, the more likely it includes methods which not all implementers can do. An interface is defined as a syntactical contract which all the classes inheriting the interface should follow. The interface defines the 'what' part of the syntactical contract and the deriving classes define the 'how' part of the syntactical contract.
https://www.tutorialspoint.com/csharp/csharp_interfaces.htm
Interfaces define properties, methods, and events, which are the members of the interface. Interfaces contain only the declaration of the members. It is the responsibility of the deriving class to define the members. It often helps in providing a standard structure which the deriving classes would follow.

Dependency inversion principle (DIP)
This principle tells you not to write any tightly coupled code because that is a nightmare to maintain when the application grows bigger. If a class depends on another class, then we need to change one class if something changes in that other dependent class. We should always try to write loosely coupled classes which avoid this problem.
There are 3 types to DI, Constructor injection, Property injection and method injection. The Dependency Inversion Principle (DIP) states that high-level modules/classes should not depend upon low-level modules/classes. Both should depend upon abstractions. Secondly, abstractions should not depend upon details. Details should depend upon abstractions.
High-level modules/classes implement business rules or logic in a system (application). Low-level modules/classes deal with more detailed operations, in other words, they may deal with writing information to databases or passing messages to the operating system or services.
A high-level module/class which has dependency on low-level modules/classes and which knows a lot about the other classes it interacts with, is said to be tightly coupled. When a class knows explicitly about the design and implementation of another class, it raises the risk that changes to one class will break the other class.

http://joelabrahamsson.com/inversion-of-control-an-introduction-with-examples-in-net/
http://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/
https://app.pluralsight.com/library/courses/aspdotnet-core-fundamentals/discussion

Relational Database
A relational database is a digital database whose organization is based on the relational model of data.

Relational model
The relational model organizes data into one or more tables (or "relations") of columns and rows, with a unique key identifying each row. The rows represent instances of that type of entity (such as "Lee" or "chair") and the columns representing values attributed to that instance (such as address or price).
The standard user and application program interface to a relational database is the structured query language (SQL). A relational database is a set of tables containing data fitted into predefined categories. Each table (which is sometimes called a relation) contains one or more data categories in columns. Each row contains a unique instance of data for the categories defined by the columns. 
For example, a typical business order entry database would include a table which described a customer with columns for name, address, phone number, and so forth. Another table would describe an order: product, customer, date, sales price, and so forth. A user of the database could obtain a view of the database which fitted the user's needs. For example, a branch office manager might like a view or report on all customers which had bought products after a certain date. 

Language-Integrated Query(LINQ)
LINQ is set of extensions to the .Net Framework 3.5 which can be used for relational databases. LINQ applies the principles of object-oriented programming to relational data. It provides a unified programming model for querying data from different types of data sources, and extends data capabilities directly into the C# and Visual Basic languages. It defines a common syntax and a programming model to query different types of data using a common language.

Entity model vs viewModel
A database stores specific pieces of information eg: Name, Address
Somewhere else in the app, there may be a view which requires the information from the database and also additional information (such as all the possible names which the database can store).
There are therefore two different concept, one for each of the use cases:
1. Entity model - an entity is an object which you use to persist (store) information in the database. The EF stores the information and only the information in the database.
2. View model, also called a Data Transfer Object (DTO) - object which carries information from the controller into the view. It contains everything which a view will need to render the html. This might require more information than is in the database. The DTO can hand information to the EF in order to save it in the database.

ConfigurationBuilder
In ASP.NET Core, it is possible to read settings from different sources like XML, JSON and INI files. The configuration API provides a way of configuring an app based on a list of name-value pairs which can be read at runtime from multiple sources. The name-value pairs can be grouped into a multi-level hierarchy. 
If you wish to leverage JSON files for your configuration, just add the Microsoft.Extensions.Configuration.Json NuGet package.

ActionResult is an abstract calss which can have several subtypes, such as:
ViewResult
RedirectResult
etc
Although all the subtypes derive from the base class, it is better for unit testing if you dont return an ActionResult when, for example, a ViewResult would have sufficed.

Get,Set
This allows you to set and receive values from a private variable, which would not otherwise be accessible. It also allows you to add events, which will notify another class when get/set occurs. Additionally, it allows for data validation at the get/set, which can prevent invalid entries from being sent to the private field. Finally, get/set allows for access control. So, you can make a field read-only or write-only. 

c# properties

A property is a member that provides a flexible mechanism to read, write, or compute the value of a private field. Properties can be used as if they are public data members, but they are actually special methods called accessors. This enables data to be accessed easily and still helps promote the safety and flexibility of methods. Properties enable a class to expose a public way of getting and setting values, while hiding implementation or verification code.
A get property accessor is used to return the property value, and a set property accessor is used to assign a new value. These accessors can have different access levels. For more information, see Restricting Accessor Accessibility.
The value keyword is used to define the value being assigned by the set accessor.
Properties can be read-write (they have both a get and a set accessor), read-only (they have a get accessor but no set accessor), or write-only (they have a set accessor, but no get accessor). Write-only properties are rare and are most commonly used to restrict access to sensitive data.

Very NB concepts

Interfaces
Constructors
Classes 
Dependency Injection
Controllers
Entities
Services
Views
ViewModels
Objects vs properties

https://docs.microsoft.com/en-us/dotnet/index
https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/index
https://docs.microsoft.com/en-us/dotnet/csharp/index
https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/index
https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties
https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/

c#
c# programs declare types, which contain members and can be organized into namespaces. Classes and interfaces are examples of types. Fields, methods, properties and events are examples of members. 

A field is a variable which is associated with a class or with an instance of a class. A field is a variable of any type which is declared directly in a class or struct. Fields are members of their containing type (class). 
Generally, fields are used for variables which have private or protected accessibility. A private field which stores data from a public property is called a backing store/field. This allows for indirect access, which guards against invalid input values. 
Fields typically store data which must be accessible to more than one class method (ie method within that class) and must be stored for longer than the lifetime of any single method. 
eg private DateTime date; //private field
Fields can be marked as private, public, protected or internal.
A field declared with the static modifier defines a static field. A static field identifies exactly one storage location. No matter how many instances of a class are created, there is only ever one copy of a static field.
A field declared without the static modifier defines an instance field. Every instance of a class contains a separate copy of all the instance fields of that class.

Variables represent storage locations. Every variable has a type which determines what values can be stored in the variable. A field is a variable of any type that is declared directly in a class or struct. Fields are members of their containing type. 
Properties expose fields. Fields should (almost always) be kept private to a class and accessed via get and set properties. Properties provide a level of abstraction allowing you to change the fields while not affecting the external way they are accessed by the things which use your class.
Object orientated programming principles say that the internal workings of a class should be hidden from the outside world. If you expose a field you're in essence exposing the internal implementation of the class. Therefore we wrap fields with Properties to give us the ability to change the implementation without breaking code. You can also put logic in the Property, which allows us to perform validation logic etc if necessary.
Another way of thinking about it is that interfaces can have properties but not fields. This, to me, underlines that properties should be used to define a class's public interface while fields are meant to be used in the private, internal workings of a class. As a rule I rarely create public fields and similarly I rarely create non-public properties.

A field is a variable which is declared directly in a class or struct. A class or struct may have instance fields or static fields or both. Generally, you should use fields only for variables which have private or protected accessibility. Data which your class exposes to client code should be provided through methods, properties and indexers. By using these constructs for indirect access to internal fields, you can guard against invalid input values.
A property is a member which provides a flexible mechanism to read, write, or compute the value of a private field. Properties can be used as if they are public data members, but they are actually special methods called accessors. This enables data to be accessed easily and still helps promote the safety and flexibility of methods. Properties enable a class to expose a public way of getting and setting values, while hiding implementation or verification code. A get property accessor is used to return the property value, and a set accessor is used to assign a new value.
Properties have the primary advantage of allowing you to change the way data on an object is accessed without breaking it's public interface. For example, if you need to add extra validation, or to change a stored field into a calculated you can do so easily if you initially exposed the field as a property. If you just exposed a field directly, then you would have to change the public interface of your class to add the new functionality. That change would break existing clients (code which uses this as an argument), which would also need to be changed in turn.
Properties support asymmetric access, i.e. you can have either a getter and a setter or just one of the two. Similarly, properties support individual accessibility for getter/setter. Fields are always symmetric, i.e. you can always both get and set the value. Exception to this is readonly fields which obviously cannot be set after initialization.
Properties may run for a very long time, have side effects, and may even throw exceptions. Fields are fast, with no side effects, and will never throw exceptions. Due to side effects a property may return a different value for each call (for example DateTime.Now, i.e. DateTime.Now is not always equal to DateTime.Now). Fields always return the same value.
Fields may be used for out / ref parameters, properties may not. Properties support additional logic – this could be used to implement lazy loading among other things.
Properties support a level of abstraction by encapsulating whatever it means to get/set the value.
Use properties in most / all cases, but try to avoid side effects.

In general, you should aim to expose properties rather than exposing fields. While you probably won't regularly find yourself saying "wow, imagine how much worse things would be if I had made this a field instead of a property", it's so much more rare to think of a situation where you would say "wow, thank God I used a field here instead of a property."
Fields are normal variable members of a class. Generally, you should declare your fields as private, then use Properties to get and set their values.
Properties are actually special methods called “accessors”. Properties are called accessors because they offer a way to get and set a field if you have a private field. They have two codes inside; set{}; and get{}; called “property accessors”.

public Methods
You may have noticed that I made the WithdrawFunds method public. This means that code running outside the class can make calls to that method. This has got to be the case, since we want people to interact with our objects by calling methods in them. In general the rules are:
? if it is a data member (i.e. it holds data) of the class, make it private
? if it is a method member (i.e. it does something) make it public
Of course, the rules can be broken on special occasions. If you don’t care about possible corruption of the member and you want your program to run as quickly as possible you can make a data member public. If you want to write a method which is only used inside a class and performs some special, secret, task you can make it private.

A property is a member which provides a mechanism to read, write or compute the value of a private field. Properties can be used as if they are public data members, but they are actually special methods called accessors. Properties enable a class to have a public way of getting and setting values. A get property accessor is used to return the property value. A set property accessor is used to assign a new value. This also allows for a property to be a read write (both a get and a set is available), read only (only a get is available) or write only (only a set is available).
Properties often have private backing fields for setting or retrieving a property value. The get returns the value of the private field. The set assigns a value to a private field. The get and set accessors may perform some sort of conversion, computation or data validation. The get keyword defines an accessor method in a property which returns the property value.

eg: class TimePeriod
{
	private double _seconds;
	
	public double Seconds
	{
		get {return _seconds;}
		set {_seconds = value;}
	}
}

For simple cases of get and set, the c# compiler can automatically just return or assign the value from a private field.

eg: class TimePeriod
{
	public double Seconds 
	{	
		{get;set;}
	}
}

float = 32 bit precision
double = 64 bit precision

c# uses type declarations to create new types. A type declaration specifies the name and members of the type. There are two kinds of types: user specified types and non-user specified types. 
User defined types are as follows:
classes - data structure containing data members (fields) and function members (methods, properties and more). They do support user specified inheritance.
structs - similar to classes, but they are value types. They do not support user specified inheritance.
interfaces - a defined contract as a named set of public function members. Implementation details for those function members are elsewhere. They do support user specified inheritance.
delegates - allows one to treat methods as values which can be assigned to a variable and passed as a parameter for a method.

Non-user defined types are as follows:
enum - type with named constants
arrays -
nullable value types - 

There are two kinds of types in c#, value types and reference types.
Value types contain the data directly. Reference types store references to their data. Reference types are known as objects. 
Structures are managed in terms of value whereas objects are managed in terms of reference.
A class provides the instructions to C# as to what is to be made, and what it can do. The new keyword causes C# to use the class information to actually make an instance.
Structures are kind of useful, but for real object oriented satisfaction you have to have an object, and that means that we must manage our access to a particular object by making use of references to it. Actually this is not that painful in reality, in that you can treat a reference as if it really was the object just about all of the time, but you must remember that when you hold a reference you do not hold an instance, you hold a tag which is tied onto an instance…

A class is a data structure which combines state (fields) and actions (methods and other functions) in a single unit. A class provides a definition for dynamically creating instances of a class, which are known as objects. 
Instances of a class are created using the new operator, which allocates memory for a new instance, invokes a constructor to initialize the instance and returns a reference to the instance.
A class or struct is a blueprint which specifies what the type can do. An object is a block of memory which has been allocated and configured according to the blueprint. A program may create many objects of the same class. Objects are also called instances.
Instances of a class are created using the new operator. Basically, instance of a type = object.

Members of a class are either static members or instance members. Static members belong to classes. Instance members belong to objects (instances of classes). Each member of a class can have different levels of accessibility.
This controls the regions of program text which are able to access a member. eg public (access not limited), protected (access limited to this class or derived class), internal, protected internal, private (access limited to this class).
The static keyword lets us create members which are not held in an instance, but in the class itself.
The AccountTest class has a static member method called Main. We know that this is the method which is called to run the program. It is part of the class AccountTest. If I made fifty AccountTest instances, they would all share the same Main method. In terms of C# the keyword static flags a member as being part of the class, not part of an instance of the class.
I don't have to make an instance of the AccountTest class to be able to use the Main method.
Say, for example, that I've been told that the interest rate is held for all the accounts. If the interest rate changes it must change for all accounts. This means that to implement the change I'd have to go through all the accounts and update the rate. This would be tedious, and if I missed one account, possibly expensive.
I solve the problem by making the interest rate member static. The interest rate is now part of the class, not part of any instance. This means that I have to change the way that I get hold of it:
Account RobsAccount = new Account(); 
RobsAccount.Balance = 100; 
Account.InterestRateCharged = 10;//call to a static member
Since it is a member of the class I now have to use the class name to get hold of it instead of the name of the instance reference.
You should be careful about how you provide access to static data items. A change to a single static value will affect your entire system. So they should always be made private and updated by means of method calls.

Inheritance means that a class implicitly contains all members of its base class. A derived class can add new members to those which it inherits, but cannot remove the definition of an inherited member. 

A method is a code block that contains a series of statements. A program causes the statements to be executed by calling the method and specifying any required method arguments. In C#, every executed instruction is performed in the context of a method. Methods are declared in a class or struct by specifying the access level such as public or private, optional modifiers such as abstract or sealed, the return value, the name of the method, and any method parameters. The method definition specifies the names and types of any parameters that are required. When calling code calls the method, it provides concrete values called arguments for each parameter. The arguments must be compatible with the parameter type but the argument name (if any) used in the calling code does not have to be the same as the parameter named defined in the method.

Iterators
An iterator performs a custom iteration over a collection, such as a list or an array. An iterator uses the yield return statement to return each element one at a time. When a yield return statement is reached, the current location in code is remembered. Execution is restarted from that location when the iterator is called the next time.
You call an iterator from client code by using a foreach statement.
The return type of an iterator can be IEnumerable, IEnumerable<T>, IEnumerator, or IEnumerator<T>.

Structs share most of the same syntax as classes, although structs are more limited than classes:
Within a struct declaration, fields cannot be initialized unless they are declared as const or static.
A struct cannot declare a default constructor (a constructor without parameters) or a finalizer.
Structs are copied on assignment. When a struct is assigned to a new variable, all the data is copied, and any modification to the new copy does not change the data for the original copy. This is important to remember when working with collections of value types such as Dictionary<string, myStruct>.
Structs are value types and classes are reference types.
Unlike classes, structs can be instantiated without using a new operator.
Structs can declare constructors that have parameters.
A struct cannot inherit from another struct or class, and it cannot be the base of a class. All structs inherit directly from System.ValueType, which inherits from System.Object.
A struct can implement interfaces.

The struct type is suitable for representing lightweight objects such as Point, Rectangle, and Color. Although it is just as convenient to represent a point as a class with Auto-Implemented Properties, a struct might be more efficient in some scenarios. For example, if you declare an array of 1000 Point objects, you will allocate additional memory for referencing each object; in this case, a struct would be less expensive. 
In C#, classes and structs are semantically different. A struct is a value type, while a class is a reference type.

The value types consist of two main categories:
Structs
Enumerations
Variables which are based on value types directly contain values. Assigning one value type variable to another copies the contained value. This differs from the assignment of reference type variables, which copies a reference to the object but not the object itself.

Variables of reference types store references to their data (objects), while variables of value types directly contain their data. With reference types, two variables can reference the same object; therefore, operations on one variable can affect the object referenced by the other variable. With value types, each variable has its own copy of the data, and it is not possible for operations on one variable to affect the other (except in the case of ref and out parameter variables).
The following keywords are used to declare reference types:
class
interface
delegate
C# also provides the following built-in reference types:
dynamic
object
string

Whenever a class or struct is created, its constructor is called. Unless the class is static, classes without constructors are given a public default constructor by the C# compiler in order to enable class instantiation. A class or struct may have multiple constructors which take different arguments. Constructors enable the programmer to set default values, limit instantiation, and write code which is flexible and easy to read.
When a class or struct is created, its constructor is called. Constructors have the same name as the class or struct, and they usually initialize the data members of the new object.
For example, if a class named Taxi is defined by using a simple constructor, the class will then be instantiated with the new operator. The Taxi constructor is then invoked by the new operator immediately after memory is allocated for the new object.
A constructor which takes no parameters is called a default constructor. Default constructors are invoked whenever an object is instantiated by using the new operator and no arguments are provided to new. 

Use the static modifier to declare a static member, which belongs to the type itself rather than to a specific object. The static modifier can be used with classes, fields, methods, properties, operators, events, and constructors, but it cannot be used with indexers, finalizers, or types other than classes.

A static member cannot be referenced through an instance. Instead, it is referenced through the type name. For example, consider the following class:
public class MyBaseC
{
    public struct MyStruct
    {
        public static int x = 100;
    }
}

To refer to the static member x, use the fully qualified name, MyBaseC.MyStruct.x, unless the member is accessible from the same scope:
Console.WriteLine(MyBaseC.MyStruct.x);  
While an instance of a class contains a separate copy of all instance fields of the class, there is only one copy of each static field.
https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/static

A static class is basically the same as a non-static class, but there is one difference: a static class cannot be instantiated. In other words, you cannot use the new keyword to create a variable of the class type. Because there is no instance variable, you access the members of a static class by using the class name itself. For example, if you have a static class that is named UtilityClass that has a public method named MethodA, you call the method as shown in the following example: +
UtilityClass.MethodA();

A static class can be used as a convenient container for sets of methods which just operate on input parameters and do not have to get or set any internal instance fields. For example, in the .NET Framework Class Library, the static System.Math class contains methods which perform mathematical operations, without any requirement to store or retrieve data which is unique to a particular instance of the Math class. 
A static constructor is only called once, and a static class remains in memory for the lifetime of the application domain in which your program resides.
Creating a static class is therefore basically the same as creating a class which contains only static members and a private constructor. A private constructor prevents the class from being instantiated. The advantage of using a static class is that the compiler can check to make sure that no instance members are accidentally added. The compiler will guarantee that instances of this class cannot be created.
Although a field cannot be declared as static const, a const field is essentially static in its behavior. It belongs to the type, not to instances of the type. Therefore, const fields can be accessed by using the same ClassName.MemberName notation which is used for static fields. No object instance is required.

The this keyword refers to the current instance of the class and is also used as a modifier of the first parameter of an extension method. Static member functions, because they exist at the class level and not as part of an object, do not have a this pointer. It is an error to refer to this in a static method.
https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/this

Events enable a class or object to notify other classes or objects when something of interest occurs. The class which sends (or raises) the event is called the publisher and the classes which receive (or handle) the event are called subscribers.
In a typical C# application, you subscribe to events raised by controls such as buttons and list boxes. The publisher determines when an event is raised; the subscribers determine what action is taken in response to the event.
An event can have multiple subscribers. A subscriber can handle multiple events from multiple publishers.

Anonymous types provide a convenient way to encapsulate a set of read-only properties into a single object without having to explicitly define a type first. The type name is generated by the compiler and is not available at the source code level (the code which you write). The type of each property is inferred by the compiler.
You create anonymous types by using the new operator together with an object initializer. For more information about object initializers, see Object and Collection Initializers.
The following example shows an anonymous type which is initialized with two properties named Amount and Message.
var v = new { Amount = 108, Message = "Hello" };  

// Rest the mouse pointer over v.Amount and v.Message in the following  
// statement to verify that their inferred types are int and string.  
Console.WriteLine(v.Amount + v.Message); 

Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance. Polymorphism is a Greek word which means "many-shaped".
At run time, objects of a derived class may be treated as objects of a base class in places such as method parameters and collections or arrays. When this occurs, the object's declared type is no longer identical to its run-time type.
Base classes may define and implement virtualmethods, and derived classes can override them, which means they provide their own definition and implementation. At run-time, when client code calls the method, the CLR looks up the run-time type of the object, and invokes that override of the virtual method. Thus in your source code you can call a method on a base class, and cause a derived class's version of the method to be executed.
Virtual methods enable you to work with groups of related objects in a uniform way. For example, suppose you have a drawing application which enables a user to create various kinds of shapes on a drawing surface. You do not know at compile time which specific types of shapes the user will create. However, the application has to keep track of all the various types of shapes which are created, and it has to update them in response to user mouse actions. You can use polymorphism to solve this problem in two basic steps:
Create a class hierarchy in which each specific shape class derives from a common base class.
Use a virtual method to invoke the appropriate method on any derived class through a single call to the base class method.
First, create a base class called Shape, and derived classes such as Rectangle, Circle, and Triangle. Give the Shape class a virtual method called Draw, and override it in each derived class to draw the particular shape that the class represents. Create a List<Shape> object and add a Circle, Triangle and Rectangle to it. To update the drawing surface, use a foreach loop to iterate through the list and call the Draw method on each Shape object in the list. Even though each object in the list has a declared type of Shape, it is the run-time type (the overridden version of the method in each derived class) which will be invoked.

Virtual Members
When a derived class inherits from a base class, it gains all the methods, fields, properties and events of the base class. A derived class can override a base class member only if the base class member is declared as virtual or abstract. The derived member must use the override keyword to explicitly indicate that the method is intended to participate in virtual invocation.

C# is an object-oriented language, but C# further includes support for component-oriented programming. Contemporary software design increasingly relies on software components in the form of self-contained and self-describing packages of functionality. C# a very natural language in which to create and use software components.
Several C# features aid in the construction of robust and durable applications: Garbage collection automatically reclaims memory occupied by unreachable unused objects; exception handling provides a structured and extensible approach to error detection and recovery; and the type-safe design of the language makes it impossible to read from uninitialized variables, to index arrays beyond their bounds, or to perform unchecked type casts.
C# has a unified type system, which means that all C# types, including primitive types such as int and double, inherit from a single root object type. Thus, all types share a set of common operations, and values of any type can be stored, transported, and operated upon in a consistent manner. Furthermore, C# supports both user-defined reference types and value types, allowing dynamic allocation of objects as well as in-line storage of lightweight structures.

The key organizational concepts in C# are: programs, namespaces, types, members, and assemblies. C# programs consist of one or more source files. Programs declare types, which contain members and can be organized into namespaces. Classes and interfaces are examples of types. Fields, methods, properties, and events are examples of members.

There are two kinds of types in C#: value types and reference types. Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects. With reference types, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable. With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other (except in the case of ref and out parameter variables).
C# programs use type declarations to create new types. A type declaration specifies the name and the members of the new type. Five of C#’s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.
A class type defines a data structure which contains data members (fields) and function members (methods, properties, and others). Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.
A struct type is similar to a class type in that it represents a structure with data members and function members. However, unlike classes, structs are value types and do not typically require heap allocation. Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type object.
An interface type defines a contract as a named set of public function members. A class or struct which implements an interface must provide implementations of the interface’s function members. An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.
A delegate type represents references to methods with a particular parameter list and return type. Delegates make it possible to treat methods as entities which can be assigned to variables and passed as parameters. Delegates are analogous to function types provided by functional languages. 
The class, struct, interface and delegate types all support generics, whereby they can be parameterized with other types.
An enum type is a distinct type with named constants. Every enum type has an underlying type, which must be one of the eight integral types. The set of values of an enum type is the same as the set of values of the underlying type.

C# supports single- and multi-dimensional arrays of any type. Unlike the types listed above, array types do not have to be declared before they can be used. Instead, array types are constructed by following a type name with square brackets. For example, int[] is a single-dimensional array of int, int[,] is a two-dimensional array of int, and int[][] is a single-dimensional array of single-dimensional array of int.
C#’s type system is unified such that a value of any type can be treated as an object. Every type in C# directly or indirectly derives from the object class type, and object is the ultimate base class of all types. Values of reference types are treated as objects simply by viewing the values as type object. Values of value types are treated as objects by performing boxing and unboxing operations. In the following example, an int value is converted to object and back again to int.+

Expressions are constructed from operands and operators. The operators of an expression indicate which operations to apply to the operands. Examples of operators include +, -, *, /, and new.
new T(...): Object and delegate creation
new T(...){...}: Object creation with initializer
new {...}: Anonymous object initializer
new T[...]: Array creation

The using statement is used to obtain a resource, execute a statement, and then dispose of that resource.
static void UsingStatement(string[] args) 
{
    using (TextWriter w = File.CreateText("test.txt")) 
    {
        w.WriteLine("Line one");
        w.WriteLine("Line two");
        w.WriteLine("Line three");
    }
}

Namespace
A namespace is a place where particular names have meaning (it provides context). We have namespaces in our conversations too, if I am using the "Football" namespace and I say “That team is really on fire” I'm saying something good. If I am using the "Firefighter" namespace I'm saying something less good.
It is possible to put one namespace inside another (just like a librarian would put a cabinet of Vases in the Roman room which he could refer to as Roman.Vases) and so the IO namespace is actually held within the System namespace. However, just because you use a namespace, this does not imply that you use all the namespaces defined within it

Classes
A C# program is made up of one or more classes. A class is a container which holds data and program code in order to do a particular job. Every class must have an identifier name. There is a convention that the name of the file which contains a particular class should match the class itself, in other words the program above should be held in a file called GlazerCalc.cs.
A class groups methods and data into an object orientated building block. A class is a kind of type. The new operator creates instances of a custom type.

A method is a group of statements which have been given a name which represents that code. You can then refer to that code by name, rather than typing out the code again.
A Method performs an action in a series of statements. The Method Main() is the default starting point for a c# program.

A parameter is the special kind of variable which is defined in the method header and used inside that method to represent the value which was fed into the method call.
static int sillyReturnPlus ( int i) 
{ 
    i = i + 1; 
    Console.WriteLine ( "i is : " + i ); 
    return i; 
}
The method sillyReturnPlus above has a single parameter, which is of type integer and has the identifier i.
An argument is the value that is supplied to the method when it is called. eg: sillyReturnPlus(99);
In the statement above the argument is the value 99.

If you want to make method calls and not have to worry about the order of the arguments you can name each one: x = readValue(low:25, high:100, prompt: "Enter your age");
Now the compiler is using the name of each argument, rather than its positon in the list. This has the useful side effect of making it much clearer to someone reading your code the exact meaning of each argument value.

Static class members
If you make the data member of the class above (OtherMethod) static, you are making sure it is part of the class and not an instance of the class. 
One common programming mistake is to confuse static with const. Marking a variable as const means “the value cannot be changed”. Marking a variable with static means “the variable is part of the class and is always present”. 
If it helps you can think of static as something which is always with us, like the background static noise on your radio when you tune it off station. Alternatively you can think of it as stationary, and therefore not going anywhere. 
This keyword makes sure that the method which follows is always present, i.e. the word static in this context means "is part of the enclosing class and is always here".
Static methods can only access static variables.

A float is a less precise version of a double.

In C# an identifier is a name that the programmer chooses for something in the program. The name of a variable is more properly called an identifier.
c# code, when stored in plain text files, have the extension .cs added to the end of the fileName. eg HelloWorld.cs. Your code can be compiled in the terminal with the C# compiler which is downloaded with Visual Studio.
Open up Developer Command Prompt (which is found under Start>Visual Studio>Visual Studio Tools, this is different to the normal Command Prompt) and cd into the directory where your saved file is located. eg cd C:\Users\8460p\Dropbox
Then, type in "csc HelloWorld.cs" in order to compile your HelloWorld.cs file. This will produce a file in the same folder, named HelloWorld.exe.
In the same command line type: "HelloWorld.exe" to execute the file.
If you type: "HelloWorld.exe &pause", the system will wait until you hit any key to continue.
You can also double click on the exe file, however, this will open a seperate Command line window which will close as soon as there is an error or the program has finished. This can be problematic because it will often close too quickly for you to see any output.

You can give the compiler a few additional options, such as:
/out allows you to set the file name of the assembly to be created. If not specified then the output is the same as the initial *.cs file name
/target:exe allows you to set the default assembly output to an executable. This is the default and it can be removed for this type of application
/target:library allows you to set the assembly output to a *.dll
/target:winexe prevents the console application from appearing in the background

eg csc /target:exe /out:HelloWorld_New.exe HelloWorld.cs

Another way to compile C# programs (without using Visual Studio or without having it installed) is to create a user variable in environment variables, namely "PATH".
Copy the following path in this variable:
"C:\Windows\Microsoft.NET\Framework\v4.0.30319"
or something similar, depending upon which .NET version your PC has. This means that you don't have to mention the whole path every time you compile your code. Simply use:
"C:\Users\UserName\Desktop>csc [options] filename.cs"
or something similar, depending on the folder path of your code.

https://www.codetuts.tech/compile-c-sharp-command-line/

Casting
We can force C# to regard a value as being of a certain type by the use of casting. A cast takes the form of an additional instruction to the compiler to force it to regard a value in a particular way. You cast a value by putting the type you want to see there in brackets before it. For example:
int i = 3, j = 2 ; 
float fraction = (float) i / (float) j ;
The (float) cast in the above tells the compiler to regard the values in the integer variables as floating point ones, so that we get 1.5 printed out rather than 1.

There is a convention that you always give constant variables names which are expressed in CAPITAL LETTERS. This is so that when you read your program you can tell which things have been defined.
eg const double MAX_WIDTH = 5.0;

Some other shorthand operators are:
a += b
the value in a is replaced by a + b
a -= b
the value in a is replaced by a – b
a /= b
the value in a is replaced by a / b
a *= b
the value in a is replaced by a * b

i++
Means “Give me the value before the increment”
++i
Means “Give me the value after the increment”

Adjusting real number precision
Placeholders can have formatting information added to them:
int i = 150 ; 
double f = 1234.56789 ; 
Console.WriteLine ( "i: {0:0} f: {1:0.00}", i, f ) ;
This would print out:
i: 150 f: 1234.57
The 0 characters stand for one or more digits. When placed after a decimal point they can be used to control the number of decimal places which are used to express a value. Note that doing this means that if the number is an integer it is printed out as 12.00.
Specifying the number of printed digits
I can specify a particular number of digits by putting in a given number of zeroes:
int i = 150 ; double f = 1234.56789 ; Console.WriteLine ( "i: {0:0000} f: {1:00000.00}", i, f );
This would print out:
i: 0150 f: 01234.57
Note that if I do this I get leading zeroes printed out, which is useful if you are printing things like cheques.
Really Fancy Formatting
If you want really fancy levels of control you can use the # character. A # in the format string means “put a digit here if you have one”:
int i = 150 ; double f = 1234.56789 ; Console.WriteLine ( "i: {0:#,##0} f: {1:##,##0.00}", i, f );

Printing in columns
Finally I can add a width value to the print layout information. This is very useful if you want to print material in columns:
int i = 150 ; double f = 1234.56789 ; Console.WriteLine ( "i: {0,10:0} f: {1,15:0.00}", i, f ) ; Console.WriteLine ( "i: {0,10:0} f: {1,15:0.00}", 0, 0 ) ;
This would produce the output:
i: 150 f: 1234.57 i: 0 f: 0.00
The integer value is printed in a column 10 characters wide, and the double is printed in a 15 character wide column. At the moment the output is right justified, if I want the numbers left justified I make the width negative:
int i = 150 ; double f = 1234.56789 ; Console.WriteLine ( "i: {0,-10:0} f: {1,-15:0.00}", i, f ) ; Console.WriteLine ( "i: {0,-10:0} f: {1,-15:0.00}", 0, 0 ) ;
This would produce the output:
i: 150 f: 1234.57 i: 0 f: 0.00
Note that this justification would work even if you were printing a string rather than a number, so if you want to print columns of words you can use this technique to do it.
You can specify the print width of any item, even a piece of text, which makes printing in columns very easy.

Call by reference of methods
Consider the code:
static void addOneToRefParam ( ref int i ) 
{
    i = i + 1; 
    Console.WriteLine ( "i is : " + i ); 
}
Note that the keyword ref has been added to the information about the parameter.
test = 20 ; 
addOneToRefParam(ref test); 
Console.WriteLine ( "test is : " + test );
The code above makes a call to the new method, and also has the word ref in front of the parameter.
Note that you have to put the word ref in the method heading and also in the call of the method.

Passing Parameter values as "out" references
When you pass a parameter as a reference you are giving the method complete control of it. So, the method can perform operations on the variable, such as divide, multiply and add. Sometimes you don't want this. Instead you want to just allow the method to give the variable a value. This is the case when we want to read in the name and age of a user. The original value of the parameters is of no interest to the method. Instead it just wants to deliver results to them. In this case I can replace the ref with the keyword out:
static void readPerson ( out string name, out int age ) 
{ 
    name = readString ( "Enter your name : " ); 
    age = readInt ( "Enter your age : ", 0, 100 ); 
}
The method readPerson reads the name and the age of a person. Note that it uses two more methods which have been created, readString and readInt.
I can call readPerson as follows:
string name; 
int age; 
readPerson ( out name, out age ) ;
Note that I must use the out keyword in the call of the method as well.
The readPerson method will read the person and deliver the information into the two variables.

Local variables are all very well, but they disappear when the program execution leaves the block where they are declared. We often need to have variables that exist outside the methods in a class.
Variables Local to a Method, consider the following code:
class LocalExample 
{ 
    static void OtherMethod () 
    { 
        local = 99; // this will not compile 
    } 
    static void Main () 
    { 
        int local = 0; 
        Console.WriteLine ("local is :" + local); 
    } 
}

The variable local is declared and used within the Main method, and can’t be used anywhere else. If a statement in OtherMethod tries to use local the program will fail to compile.

If you want to allow two methods in a class to share a variable I will have to make the variable a member of the class. This means declaring it outside the methods in the class:
class MemberExample
{ 
    // the variable member is part of the class 
    static int member = 0;
    
    static void OtherMethod () 
    { 
        member = 99; 
    } 
    static void Main () 
    { 
        Console.WriteLine ("member is : " + member); 
        OtherMethod(); Console.WriteLine ("member is now : " + member); 
    } 
}

The variable member is now part of the class MemberExample, and so the Main method and OtherMethod can both use this variable.

C# provides us with a thing called an array. We then access entries in the array using subscripts. Consider the following:
using System; 

class ArrayDemo 
{ 
    public static void Main () 
    { 
        int [] scores = new int [11]; 
        for ( int i=0; i<11; i=i+1) 
        { 
            scores [i] = readInt ( "Score : ", 0,1000); 
        } 
    } 
}
The int [] scores part tells the compiler that we want to create an array variable. You can think of this as a tag which can be made to refer to a given array.
C# numbers the boxes starting at 0. This means that you specify the element at the start of the array by giving the subscript 0.

However, sometimes we want to hold more than just a row. Sometimes we want a grid. We can do this by creating a two dimensional array. You can think of this as an "array of arrays" if you like (but only if this doesn't make your head hurt). For example, to hold the board for a game of noughts and crosses (tic tac toe) we could use:
int [,] board = new int [3,3]; 
board [1,1] = 5; //Here, you are setting the value of row 1, column 1 to 5
This looks very like our one dimensional array, but there are some important differences. The [,] now has a comma. The presence of a comma implies something each side of it. This means that the array now has two dimensions, rather than just one.
The first subscript could be used to specify which row and the second which column.

Initialising arrays
string[] monthNames = new string[] 
{ 
    null, // null element for non existent month 0 
    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" 
};
A program can contain a list of initialisation values which are then used to create an array with the required content. Note that the initialisation process will even work out
the length of the array automatically if required. You can also initialise 2D arrays as well. 
int [,] squareWeights = new int [3,3] 
{ 
{1,0,1}, 
{0,2,0}, 
{1,0,1} 
};

We can make our programs deal with invalid text input to Parse by adding code that will catch the exceptions which Parse throws and try to fix the problem. In programming terms this is called “dynamic error handling” in that our program is responding to an error when it occurs. To do this we have to use a new C# construction, the try – catch clause. The try keyword is followed by a block of code. After the block of code comes the catch clause. If any of the statements following the try throws an exception the program runs the code in the catch clause to handle this error.
int age; 
try 
{ 
    age = int.Parse(ageString); 
    Console.WriteLine("Thank you"); 
} 
catch 
{ 
    Console.WriteLine("Invalid age value"); 
}

Simple Exception Catching
The code above uses Parse to decode the age string. However, the parse action takes place inside the try block. If the call of Parse throws an exception, the code in the catch block runs and will display a message to the user. Note that once the exception has been thrown, the code does not return to the try block.
When Parse fails it creates an exception object which describes the bad thing which has just happened (in this case input string not in the correct format). 
The program above ignores the exception object and just registers to the exception event but we can improve the diagnostics of our program by catching the exception if we wish:

int age; 
try 
{ 
    age = int.Parse(ageString); 
    Console.WriteLine("Thank you"); 
} 

catch (Exception e) 
{   // Get the error message out of the exception 
    Console.WriteLine(e.Message); 
}

The catch now looks like a method call, with the Exception e being a parameter to the method. This is exactly how it works. Within the catch clause the value of e is set to the exception that was thrown by Parse. The Exception type has a property called Message which contains a string describing the error. If a user types in an invalid string the program above will write the text in the exception, which contains the message: Input string was not in a correct format.
This message is obtained from the exception which was thrown. This is useful if the code inside the try block could throw several different kinds of exception, since it means that the message reflects what has actually happened. The Exception object also contains other properties which can be useful.
Programs can have multiple levels of try – catch, and the program will use the catch which matches the level of the code in the try block.

Sometimes there are things which your program must do irrespective of whether or not an exception is thrown. These actions include things like closing files, releasing resources and generally tidying up. However, we know that when an exception is thrown the statements in the catch clause are called, and the program never returns to the try part of the program. The code in the catch clause could return from the method it is running within or even throw an exception itself. In these situations any code following your try – catch construction would not get the chance to run.
Fortunately C# provides a solution to this problem by allowing you to add a finally clause to your try-catch construction. Statements inside the finally clause will run irrespective of whether or not the program in the try block throws an exception.

finally 
{ 
    // Code that is obeyed whether an exception 
    // is thrown or not 
}

C# contains a special construction to allow you to select one option from a number of them based on a particular value.
switch (selection) 
{ 
    case 1 : 
        handleCasement (); 
        break ; 
    case 2 : handleStandard ();
    break ;
    default : Console.WriteLine ( "Invalid number" ); 
    break; 
}

You can also fall through with c# switch statements. ie it continues to execute until it finds a break.
switch (command)
{
    case "casement" : 
    case "c" : 
        handleCasement (); 
        break ;
}

You can use switch commands with things like strings in c# too.

Streams and Files
Like lots of the objects that deal with input and output, this object is defined in the System.IO namespace. You create a stream object just like you would create any other one, by using new. When the stream is created it can be passed the name of the file that is to be opened.
StreamWriter writer; 
writer = new StreamWriter("test.txt");
Note that StreamWriter will overwrite the file test.txt, if it already exists.
Once the stream has been created, it can be written to by calling the write methods, it provides:
writer.WriteLine("hello world");
The above statement calls the WriteLine method on the stream, in order to make it write the text “hello world” into the file test.txt.

When your program has finished writing to a stream it is very important that the stream is explicitly closed using the Close method:
writer.Close();
When the Close method is called the stream will write out any text to the file that is waiting to be written and disconnect the program from the file. Any further attempts to write to the stream will fail with an exception.

Reading from a file is very similar to writing, in that the program will create a stream to do the actual work. In this case the stream that is used is a StreamReader.
StreamReader reader = new StreamReader("Test.txt"); 
string line = reader.ReadLine(); 
Console.WriteLine (line);
reader.Close();

The above program connects a stream to the file Test.txt, reads the first line from the file, displays it on the screen and then closes the stream. If the file can’t be found, then the attempt to open it will fail and the program will throw an exception.
The StreamReader object provides a property called EndOfStream which a program can use to determine when the end of the file has been reached. When the property becomes true, the end of the file has been reached.

StreamReader reader = new StreamReader("Test.txt"); 
while (reader.EndOfStream == false) 
{ 
    string line = reader.ReadLine(); 
    Console.WriteLine(line); 
} 
reader.Close();

If you want to use a file in a different folder (which is a good idea, as data files are hardly ever held in the same place as programs run from) you can add path information to a filename:
string path; 
path = @"c:\data\2009\November\sales.txt";

The backslash (\) characters in the string serve to separate the folders along the path to the file. Note that I have specified a string literal that doesn’t contain control characters (that is what the @ at the beginning of the literal means)

Enumeration and states
Enumerated sounds posh. But if you think of "enumerated" as just meaning "numbered" things get a bit easier. To understand what we are doing here we need to consider the problem which these types are intended to solve.
We know that if we want to hold an integer value we can use an int type. If we want to hold something which is either true or false we can use a bool. However, sometimes we want to hold a range of particular values or states.

Enumerated types are very useful when storing state information. States are not quite the same as other items such as the name of a customer or the balance of their account.
For example, if I am writing a program to play the game Battleships (where squares of the "sea" hold different types of craft which can be attacked) I may decide that a given square of the sea can have the following thing in it:
Empty sea
Attacked
Battleship
Cruiser
Submarine
Rowing boat

C# has a way in which we can create a type which has just a particular set of possible values. These types are called "enumerated types":
enum SeaState 
{ 
    EmptySea, Attacked, Battleship, Cruiser, Submarine, RowingBoat 
} ;
I have created a type called SeaState which can be used to hold the state of a particular part of the sea. It can only have the given values above, and must be managed solely in terms of these named enumerations. For example I must write:
SeaState openSea ; 
openSea = SeaState.EmptySea;
My variable openSea is only able to hold values which represent the state of the sea contents. Of course C# itself will actually represent these states as particular numeric values, but how these are managed is not a problem for me.
The new enum type can be created outside any class and creates a new type for use in any of my programs

Using Structure Types in Method Calls
A method can have parameters of structure type:
public void PrintAccount ( Account a ) 
{ 
    Console.WriteLine ( "Name: " + a.Name ); 
    Console.WriteLine ( "Address: " + a.Address ); 
    Console.WriteLine ( "Balance: " + a.Balance ); 
}
This method provides a quick way of printing out the contents of an account variable:
PrintAccount (RobsAccount);

It is also possible to create methods that return results which are of a structure type, for example we could create a ReadAccount method that reads an account and returns it.
Unlike classes, structures cannot inherit from other structures.