Very NB concepts

Interfaces
Constructors
Classes 
Dependency Injection
Controllers
Entities
Services
Views
ViewModels
Objects vs properties

https://docs.microsoft.com/en-us/dotnet/index
https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/index
https://docs.microsoft.com/en-us/dotnet/csharp/index
https://docs.microsoft.com/en-us/dotnet/csharp/tour-of-csharp/index
https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/properties
https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interfaces/

c#

C# is an object-oriented language, but C# further includes support for component-oriented programming. Contemporary software design increasingly relies on software components in the form of self-contained and self-describing packages of functionality. Key to such components is that they present a programming model with properties, methods, and events; they have attributes which provide declarative information about the component; and they incorporate their own documentation. C# provides language constructs to support directly these concepts, making C# a very natural language in which to create and use software components.
Several C# features aid in the construction of robust and durable applications: Garbage collection automatically reclaims memory occupied by unreachable unused objects; exception handling provides a structured and extensible approach to error detection and recovery; and the type-safe design of the language makes it impossible to read from uninitialized variables, to index arrays beyond their bounds, or to perform unchecked type casts.
C# has a unified type system. All C# types, including primitive types such as int and double, inherit from a single root object type. Thus, all types share a set of common operations, and values of any type can be stored, transported, and operated upon in a consistent manner. Furthermore, C# supports both user-defined reference types and value types, allowing dynamic allocation of objects as well as in-line storage of lightweight structures.

The key organizational concepts in C# are programs, namespaces, types, members, and assemblies. C# programs consist of one or more source files. Programs declare types, which contain members and can be organized into namespaces. Classes and interfaces are examples of types. Fields, methods, properties, and events are examples of members.
There are two kinds of types in C#: value types and reference types. Variables of value types directly contain their data whereas variables of reference types store references to their data, the latter being known as objects. With reference types, it is possible for two variables to reference the same object and thus possible for operations on one variable to affect the object referenced by the other variable. With value types, the variables each have their own copy of the data, and it is not possible for operations on one to affect the other (except in the case of ref and out parameter variables).
C# programs use type declarations to create new types. A type declaration specifies the name and the members of the new type. Five of C#’s categories of types are user-definable: class types, struct types, interface types, enum types, and delegate types.
A class type defines a data structure that contains data members (fields) and function members (methods, properties, and others). Class types support single inheritance and polymorphism, mechanisms whereby derived classes can extend and specialize base classes.
A struct type is similar to a class type in that it represents a structure with data members and function members. However, unlike classes, structs are value types and do not typically require heap allocation. Struct types do not support user-specified inheritance, and all struct types implicitly inherit from type object.
An interface type defines a contract as a named set of public function members. A class or struct that implements an interface must provide implementations of the interface’s function members. An interface may inherit from multiple base interfaces, and a class or struct may implement multiple interfaces.
A delegate type represents references to methods with a particular parameter list and return type. Delegates make it possible to treat methods as entities that can be assigned to variables and passed as parameters. Delegates are analogous to function types provided by functional languages. They are also similar to the concept of function pointers found in some other languages, but unlike function pointers, delegates are object-oriented and type-safe.
The class, struct, interface and delegate types all support generics, whereby they can be parameterized with other types.
An enum type is a distinct type with named constants. Every enum type has an underlying type, which must be one of the eight integral types. The set of values of an enum type is the same as the set of values of the underlying type.
C# supports single- and multi-dimensional arrays of any type. Unlike the types listed above, array types do not have to be declared before they can be used. Instead, array types are constructed by following a type name with square brackets. For example, int[] is a single-dimensional array of int, int[,] is a two-dimensional array of int, and int[][] is a single-dimensional array of single-dimensional array of int.
C#’s type system is unified such that a value of any type can be treated as an object. Every type in C# directly or indirectly derives from the object class type, and object is the ultimate base class of all types. Values of reference types are treated as objects simply by viewing the values as type object. Values of value types are treated as objects by performing boxing and unboxing operations. In the following example, an int value is converted to object and back again to int.+

Expressions are constructed from operands and operators. The operators of an expression indicate which operations to apply to the operands. Examples of operators include +, -, *, /, and new.
new T(...): Object and delegate creation
new T(...){...}: Object creation with initializer
new {...}: Anonymous object initializer
new T[...]: Array creation

The using statement is used to obtain a resource, execute a statement, and then dispose of that resource.
static void UsingStatement(string[] args) 
{
    using (TextWriter w = File.CreateText("test.txt")) 
    {
        w.WriteLine("Line one");
        w.WriteLine("Line two");
        w.WriteLine("Line three");
    }
}
c# learning websites

https://mva.microsoft.com/en-us/training-courses/c-fundamentals-for-absolute-beginners-16169?l=Lvld4EQIC_2706218949
https://www.sololearn.com/Course/CSharp/
https://code.tutsplus.com/courses/30-days-to-learn-c

done 
https://www.tutorialspoint.com/csharp/

Practicing websites
https://www.codewars.com/
http://www.programmr.com/
https://www.codingame.com/start
https://codefights.com/

ASP.NET
http://www.tutorialsteacher.com/mvc/asp.net-mvc-tutorials
https://www.tutorialspoint.com/asp.net_mvc/

XAML
https://www.tutorialspoint.com/xaml/index.htm
http://www.wpf-tutorial.com/xaml/basic-xaml/
https://www.pluralsight.com/courses/enterprise-wpf-xaml-csharp-from-scratch

Terminology

.net framework

A framework is a collection of APIs and shared library of code. A framework is code which the programmer can use without writing it explicitly in their code.
.NET is both a library of code called the Framework class library (FCL) and a runtime environment (virtual machine). The framework creates a virtual machine, in which the programs run.
The virtual machine handles things like memory management and security. The virtual machine also allows the user experience to be the same across supported languages, such as c++ and c#.
Mono is a version of .NET for linux
A library is equivalent to an exe file, but with the extension .dll; it has no entry point, but is referenced by other programs.

ASP.NET

ASP = Active Server Pages. ASP.NET is a virtual machine hosted on a server. It is a server side web technology. Allows you to develop dynamic websites and web apps.
ASP supports any .NET supported language. ASP works on top of the HTML protocol, it is also a part of the .NET framework, providing you with access to its infrastructure.
ASP has three frameworks for creating web applications: web forms, MVC and web pages.

MVC

ASP.NET MVC targets developers focussing on test-driven development. MVC = Model,View,Controllers. Splitting up a website/app in this way allows seperate teams to work on each aspect.
Each component can then also be tested independently.
Model = classes for data and logic
View = templates for HTML
Controllers = classes for browser requests and retrieving data

MVC uses different controller classes and their different action methods, depending on the incoming URL. The first part of the URL specifies the controller class to execute. So, /HelloWorld maps to the HelloWorld Controller class.
The second part of the URL specifies the method to execute. So, /HelloWorld/Index invokes the Index method of the HelloWorld Controller class. Methods which are named Index are automatically the default. Defaults are called if not explicitly specified.
http://localhost:1234/HelloWorld/Welcome

The controller handles the logic of the application and acts as the coordinator between the view and the model. The controller receives input from the user via the View. The Controller also receives relevant and processed data from the model. The controller then sends these results to the View.

When a user types a URL into the browser address bar, this calls a method, which belongs to a class. This is the Controller. 
The Model is packaged data to present to the user and which the user interacts with. It is a class. It is the data which the controller passes to the View.
The View takes the data and turns it into HTML. It is a template for the data, without any logic.

Controllers are classes with methods, models are classes without methods.

Generally, MVC is not the whole app. Other features will often be added.

Test Driven Development (TDD)

This is a software development process which relies on the repetition of extremely short development cycles. A user requirement is turned into a specific test case and then software is developed to pass that test only.
Nothing additional is added to the software, a minimum of code should be written in order to pass the test. If the software is proven to pass the test, the cycle begins again. These cycles should repeat as quickly as possible.
TDD is different to unit testing, in which the code is tested after it is written. Writing the test before the code makes you focus on the user requirement before coding.
TDD can reduce the debugging effort and makes documentation better. If used with version control software, reverting to the last successful code is often easier than debugging the current code.
This system also allows one to focus on a small chunk, rather than being overwhelmed by the whole task. Also, because all the code in the final project has been through at least one test, you have more confidence in the final solution.
The method also makes you think of software as a group of much smaller units of code, allowing one to write more modularized, flexible and extensible code.
The final result is a bunch of small code units, written and tested independently and integrated later.

Entity Framework (EF)

This is an opensource object relational mapping framework and has been added to the .NET framework. It enables one to work with data, such as customer addresses, without being concerned with where and how the data is stored.
A higher level of abstraction creates a virtual database, even if the data is stored with different languages and on different types of computer hardware.
You basically convert the data into a simpler form for storage and then convert it back, in a standardised manner upon retrieval. The Entity Framework (EF) supports a development paradigm called Code First. Code First allows you to create model objects by writing simple classes.
You can then have the database created on the fly from your classes, which enables a very clean and rapid development workflow.
There are three ways you can work with data models and databases in the Entity Framework: Database First, Model First, and Code First.
If you already have a database, the Entity Framework designer built into Visual Studio can automatically generate a data model that consists of classes and properties that correspond to existing database objects such as tables and columns. 
 If you don't have a database, you can code your own classes and properties that correspond to tables and columns. If you do have a database, Entity Framework tools can generate the classes and properties that correspond to existing tables and columns. 

Web API

An API is a set of clearly defined systems of communication between software components. This makes it easier to use the technology within the API, without a knowing specifics about how the goal is achieved.
The implementation is hidden away and only exposes the parts required by the user to interface with the code. The API describes and prescribes the expected behaviour.

Examples of web APIs are HTTP or JSON. The ASP.NET web API is a framework for building HTTP services. It is similar to ASP.NET MVC, but it is not part of the MVC framework.
The web API allows you to develop one website which is compatible with multiple browsers and mobile devices.

Windows Presentation Foundation (WPF)

WPF is the category of features in the .NET Framework which deals with the visual presentation of Windows-based applications and Web browser-based client applications.
WPF uses XAML for constructing visually stunning user interfaces (UI) in markup instead of in a programming language such as C#. 
WPF unifies how Windows creates, displays, and manipulates documents, media, and user interface (UI).

XAML - pronounced "Zammel"

This is a markup language, similar to HTML. Extensible Application Markup Language = XAML
You can create elaborate user interfaces, entirely in XAML by defining elements such as controls, text, images, shapes, animation, and more.
eg <Ellipse Fill="Gray" Height = "100"/>
When represented as text, XAML files are XML files which generally have the .xaml extension.
The XAML language defines concepts of its own, but these concepts work within the XML language and markup form.
It can be combined with c# to create logic.
XAML can be used in different platforms such as WPF (Windows Presentation Foundation), Silverlight, Mobile Development, and Windows Store App. It can be used across different .Net framework and CLR (common language runtime) versions.
In the earlier GUI frameworks, there was no real separation between how an application looks like and how it behaves. Both the GUI and its behavior were created in the same language, e.g. C# or VB.net, which would require more effort from the developer to implement both the UI and the behavior associated with it.

Visual studio

Microsoft Visual Studio is an integrated development environment (IDE) from Microsoft. 
It is used to develop computer programs for Microsoft Windows, as well as web sites, web apps, web services and mobile apps.
Visual Studio includes a code editor, with auto code completion and an integrated debugger . Other built-in tools include templates for building GUI and web apps.
As code is being written, Visual Studio compiles it in the background in order to provide feedback about syntax and compilation errors, which are flagged with a red wavy underline.

Agile software development

Agile software development describes a set of principles for software development under which requirements and solutions evolve through the collaborative effort of self-organizing cross-functional teams.
It advocates adaptive planning, evolutionary development, early delivery, and continuous improvement, and it encourages rapid and flexible response to change.
The main principles:
Individuals and interactions
Self-organization and motivation are important, as are interactions like co-location and pair programming.
Working software
Working software is more useful and welcome than just presenting documents to clients in meetings.
Customer collaboration
Requirements cannot be fully collected at the beginning of the software development cycle, therefore continuous customer or stakeholder involvement is very important.
Responding to change
Agile software development methods are focused on quick responses to change and continuous development.

Iterative, incremental and evolutionary
Most agile development methods break product development work into small increments that minimize the amount of up-front planning and design. 
Iterations are short time frames (timeboxes) which typically last from one to four weeks. Each iteration involves a cross-functional team working in all functions: planning, analysis, design, coding, unit testing, and acceptance testing. 
At the end of the iteration a working product is demonstrated to stakeholders. This minimizes overall risk and allows the product to adapt to changes quickly.
An iteration might not add enough functionality to warrant a market release, but the goal is to have an available release (with minimal bugs) at the end of each iteration. Multiple iterations might be required to release a product or new features.

Efficient and face-to-face communication
Very short feedback loop and adaptation cycle

Popular methods include:
Lean software development
Kanban
Rapid application development (RAD)
Scrum
Scrumban

Lean Software Development is considered an Agile Software Development Method.
Lean development can be summarized by seven principles, very close in concept to lean manufacturing principles:
Eliminate waste
Amplify learning
Decide as late as possible
Deliver as fast as possible
Empower the team
Build integrity in
See the whole

Razor is a markup syntax that lets you embed server-based code into web pages using C#. It is not a programming language. It is a server side markup language.
Razor has no ties to ASP.NET MVC because Razor is a general-purpose templating engine. You can use it anywhere to generate output like HTML. It's just that ASP.NET MVC has implemented a view engine that allows us to use Razor inside of an MVC application to produce HTML.
You will have a template file that's a mix of some literal text and some blocks of code. You combine that template with some data or a specific model where the template specifies where the data is supposed to appear, and then you execute the template to generate your output.
With Razor syntax you can begin a bit of C# code by using the ‘@’ sign and the Razor parse will automatically switch into parsing this statement, for each statement, as a bit of C# code.
The @ character can start inline expressions, single statement blocks and multi-statement blocks.
Basically, the @ is just where c# code has been written in a file which contains html and is a .cshtml extension.
Rendering HTML is done with the Razor view engine. To use this system, the controller action produces a ViewResult object, which can also carry the name of the specific razor view which the controller action wants to use. It can also carry a model object which it will consume.
So, it can take something like a restaurant name held in a database somewhere and place that into html. All Razor views have the extension .cshtml.
You start writing c# in a Razor View with an @. Razor then evaluates the c# expression and puts the result into the HTML.
MVC takes the view and compiles it into a Class, which will have properties and members available. 
eg @Model.Name //This gives you access to the name of the Restuarant placed into the Model object.
You can supply Razor views with directives, which sets the type of the Model property in the RazorView.
eg @model OdeToFood.ViewModels.HomePageViewModel 

@*multiline comment in Razor*@

The ViewBag syntax allows you to transfer temporary data from the controller to the view.

c#
https://www.youtube.com/user/bobtabor

c# code, when stored in plain text files, have the extension .cs added to the end of the fileName. eg HelloWorld.cs.
It can be compiled in the terminal with the C# compiler which is downloaded with Visual Studio.
Open up Developer Command Prompt (which is found under Start>Visual Studio>Visual Studio Tools) and cd into the directory where your saved file is located.
eg cd C:\Users\8460p\Dropbox
Enter "csc HelloWorld.cs"
This will produce a file in the same locale named HelloWorld.exe.
In the same command line type: "HelloWorld.exe" to execute the file.
If you type: "HelloWorld.exe &pause", the system will wait until you hit any key to continue.
You can also double click on the exe file.

You can give the compiler a few additional options, such as:
/out allows you to set the file name of the assembly to be created. If not specified then the output is the same as the initial *.cs file name
/target:exe allows you to set the default assembly output to an executable. This is the default and it can be removed for this type of application
/target:library allows you to set the assembly output to a *.dll
/target:winexe prevents the console application from appearing in the background

eg csc /target:exe /out:HelloWorld_New.exe HelloWorld.cs

Another way to compile C# programs (without using Visual Studio or without having it installed) is to create a user variable in environment variables, namely "PATH".
Copy the following path in this variable:
"C:\Windows\Microsoft.NET\Framework\v4.0.30319"
or depending upon which .NET your PC have.
So you don't have to mention the whole path every time you compile a code. Simply use
"C:\Users\UserName\Desktop>csc [options] filename.cs"
or wherever the path of your code is.

https://www.codetuts.tech/compile-c-sharp-command-line/

Namespace
A namespace is a place where particular names have meaning (it provides context). We have namespaces in our conversations too, if I am using the "Football" namespace and I say “That team is really on fire” I'm saying something good. If I am using the "Firefighter" namespace I'm saying something less good.
It is possible to put one namespace inside another (just like a librarian would put a cabinet of Vases in the Roman room which he could refer to as Roman.Vases) and so the IO namespace is actually held within the System namespace. However, just because you use a namespace, this does not imply that you use all the namespaces defined within it

Classes
A C# program is made up of one or more classes. A class is a container which holds data and program code to do a particular job. Every class must have an identifier name. There is a convention that the name of the file which contains a particular class should match the class itself, in other words the program above should be held in a file called GlazerCalc.cs.
A class groups methods and data into an object orientated building block. A class is a kind of type. The new operator creates instances of a custom type.

A float is a less precise version of a double.

In C# an identifier is a name that the programmer chooses for something in the program. The name of a variable is more properly called an identifier.

Casting
We can force C# to regard a value as being of a certain type by the use of casting. A cast takes the form of an additional instruction to the compiler to force it to regard a value in a particular way. You cast a value by putting the type you want to see there in brackets before it. For example:
int i = 3, j = 2 ; 
float fraction = (float) i / (float) j ;
The (float) cast in the above tells the compiler to regard the values in the integer variables as floating point ones, so that we get 1.5 printed out rather than 1.

There is a convention that you always give constant variables names which are expressed in CAPITAL LETTERS. This is so that when you read your program you can tell which things have been defined.
eg const double MAX_WIDTH = 5.0;

Some other shorthand operators are:
a += b
the value in a is replaced by a + b
a -= b
the value in a is replaced by a – b
a /= b
the value in a is replaced by a / b
a *= b
the value in a is replaced by a * b

i++
Means “Give me the value before the increment”
++i
Means “Give me the value after the increment”

Adjusting real number precision
Placeholders can have formatting information added to them:
int i = 150 ; 
double f = 1234.56789 ; 
Console.WriteLine ( "i: {0:0} f: {1:0.00}", i, f ) ;
This would print out:
i: 150 f: 1234.57
The 0 characters stand for one or more digits. When placed after a decimal point they can be used to control the number of decimal places which are used to express a value. Note that doing this means that if the number is an integer it is printed out as 12.00.
Specifying the number of printed digits
I can specify a particular number of digits by putting in a given number of zeroes:
int i = 150 ; double f = 1234.56789 ; Console.WriteLine ( "i: {0:0000} f: {1:00000.00}", i, f );
This would print out:
i: 0150 f: 01234.57
Note that if I do this I get leading zeroes printed out, which is useful if you are printing things like cheques.
Really Fancy Formatting
If you want really fancy levels of control you can use the # character. A # in the format string means “put a digit here if you have one”:
int i = 150 ; double f = 1234.56789 ; Console.WriteLine ( "i: {0:#,##0} f: {1:##,##0.00}", i, f );

Printing in columns
Finally I can add a width value to the print layout information. This is very useful if you want to print material in columns:
int i = 150 ; double f = 1234.56789 ; Console.WriteLine ( "i: {0,10:0} f: {1,15:0.00}", i, f ) ; Console.WriteLine ( "i: {0,10:0} f: {1,15:0.00}", 0, 0 ) ;
This would produce the output:
i: 150 f: 1234.57 i: 0 f: 0.00
The integer value is printed in a column 10 characters wide, and the double is printed in a 15 character wide column. At the moment the output is right justified, if I want the numbers left justified I make the width negative:
int i = 150 ; double f = 1234.56789 ; Console.WriteLine ( "i: {0,-10:0} f: {1,-15:0.00}", i, f ) ; Console.WriteLine ( "i: {0,-10:0} f: {1,-15:0.00}", 0, 0 ) ;
This would produce the output:
i: 150 f: 1234.57 i: 0 f: 0.00
Note that this justification would work even if you were printing a string rather than a number, so if you want to print columns of words you can use this technique to do it.
You can specify the print width of any item, even a piece of text, which makes printing in columns very easy.

A method is a group of statements which have been given a name which represents that code. You can then refer to that code by name, rather than typing out the code again.
A Method performs an action in a series of statements. The Method Main() is the default starting point for a c# program.

A parameter is the special kind of variable that is defined in the method header and used inside that method to represent the value that was fed into the method call.
static int sillyReturnPlus ( int i) 
{ 
    i = i + 1; 
    Console.WriteLine ( "i is : " + i ); 
    return i; 
}
The method sillyReturnPlus above has a single parameter, which is of type integer and has the identifier i.
An argument is the value that is supplied to the method when it is called.
sillyReturnPlus(99);
In the statement above the argument is the value 99.

If you want to make method calls and not have to worry about the order of the arguments you can name each one: x = readValue(low:25, high:100, prompt: "Enter your age");
Now the compiler is using the name of each argument, rather than its positon in the list. This has the useful side effect of making it much clearer to someone reading your code the exact meaning of each argument value.


Call by reference of methods
Consider the code:
static void addOneToRefParam ( ref int i ) 
{
    i = i + 1; 
    Console.WriteLine ( "i is : " + i ); 
}
Note that the keyword ref has been added to the information about the parameter.
test = 20 ; 
addOneToRefParam(ref test); 
Console.WriteLine ( "test is : " + test );
The code above makes a call to the new method, and also has the word ref in front of the parameter.
Note that you have to put the word ref in the method heading and also in the call of the method.

Passing Parameter values as "out" references
When you pass a parameter as a reference you are giving the method complete control of it. So, the method can perform operations on the variable, such as divide, multiply and add. Sometimes you don't want this. Instead you want to just allow the method to give the variable a value. This is the case when we want to read in the name and age of a user. The original value of the parameters is of no interest to the method. Instead it just wants to deliver results to them. In this case I can replace the ref with the keyword out:
static void readPerson ( out string name, out int age ) 
{ 
    name = readString ( "Enter your name : " ); 
    age = readInt ( "Enter your age : ", 0, 100 ); 
}
The method readPerson reads the name and the age of a person. Note that it uses two more methods that I have created, readString and readInt.
I can call readPerson as follows:
string name; 
int age; 
readPerson ( out name, out age ) ;
Note that I must use the out keyword in the call of the method as well.
The readPerson method will read the person and deliver the information into the two variables.


Local variables are all very well, but they disappear when the program execution leaves the block where they are declared. We often need to have variables that exist outside the methods in a class.
Variables Local to a Method, consider the following code:
class LocalExample 
{ 
    static void OtherMethod () 
    { 
        local = 99; // this will not compile 
    } 
    static void Main () 
    { 
        int local = 0; 
        Console.WriteLine ("local is :" + local); 
    } 
}

The variable local is declared and used within the Main method, and can’t be used anywhere else. If a statement in OtherMethod tries to use local the program will fail to compile.


If I want to allow two methods in a class to share a variable I will have to make the variable a member of the class. This means declaring it outside the methods in the class:
class MemberExample
{ 
    // the variable member is part of the class 
    static int member = 0;
    
    static void OtherMethod () 
    { 
        member = 99; 
    } 
    static void Main () 
    { 
        Console.WriteLine ("member is : " + member); 
        OtherMethod(); Console.WriteLine ("member is now : " + member); 
    } 
}

The variable member is now part of the class MemberExample, and so the Main method and OtherMethod can both use this variable.


Static class members
If you make the data member of the class above (OtherMethod) static, you are making sure it is part of the class and not an instance of the class. 
This is not something to worry about just now; we will investigate the precise meaning of static later on. For now you just have to remember to put in the static keyword, otherwise your program will not compile.
One common programming mistake is to confuse static with const. Marking a variable as const means “the value cannot be changed”. 
Marking a variable with static means “the variable is part of the class and is always present”. 
If it helps you can think of static as something which is always with us, like the background static noise on your radio when you tune it off station. 
Alternatively you can think of it as stationary, and therefore not going anywhere. 
This keyword makes sure that the method which follows is always present, i.e. the word static in this context means "is part of the enclosing class and is always here".
Static methods can only access static variables.

C# provides us with a thing called an array. We then access entries in the array using subscripts. Consider the following:
using System; 

class ArrayDemo 
{ 
    public static void Main () 
    { 
        int [] scores = new int [11]; 
        for ( int i=0; i<11; i=i+1) 
        { 
            scores [i] = readInt ( "Score : ", 0,1000); 
        } 
    } 
}
The int [] scores part tells the compiler that we want to create an array variable. You can think of this as a tag which can be made to refer to a given array.
C# numbers the boxes starting at 0. This means that you specify the element at the start of the array by giving the subscript 0.

However, sometimes we want to hold more than just a row. Sometimes we want a grid. We can do this by creating a two dimensional array. You can think of this as an "array of arrays" if you like (but only if this doesn't make your head hurt). For example, to hold the board for a game of noughts and crosses (tic tac toe) we could use:
int [,] board = new int [3,3]; 
board [1,1] = 5; //Here, you are setting the value of row 1, column 1 to 5
This looks very like our one dimensional array, but there are some important differences. The [,] now has a comma. The presence of a comma implies something each side of it. This means that the array now has two dimensions, rather than just one.
The first subscript could be used to specify which row and the second which column.


Initialising arrays
string[] monthNames = new string[] 
{ 
    null, // null element for non existent month 0 
    "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" 
};
A program can contain a list of initialisation values which are then used to create an array with the required content. Note that the initialisation process will even work out
the length of the array automatically if required. You can also initialise 2D arrays as well. 
int [,] squareWeights = new int [3,3] 
{ 
{1,0,1}, 
{0,2,0}, 
{1,0,1} 
};

We can make our programs deal with invalid text input to Parse by adding code that will catch the exceptions which Parse throws and try to fix the problem. In programming terms this is called “dynamic error handling” in that our program is responding to an error when it occurs. To do this we have to use a new C# construction, the try – catch clause. The try keyword is followed by a block of code. After the block of code comes the catch clause. If any of the statements following the try throws an exception the program runs the code in the catch clause to handle this error.
int age; 
try 
{ 
    age = int.Parse(ageString); 
    Console.WriteLine("Thank you"); 
} 
catch 
{ 
    Console.WriteLine("Invalid age value"); 
}

Simple Exception Catching
The code above uses Parse to decode the age string. However, the parse action takes place inside the try block. If the call of Parse throws an exception the code in the catch block runs and will display a message to the user. Note that once the exception has been thrown there is no return to the code in the try block

When Parse fails it creates an exception object that describes the bad thing that has just happened (in this case input string not in the correct format). 
The program above ignores the exception object and just registers to the exception event but we can improve the diagnostics of our program by catching the exception if we wish:

int age; 
try 
{ 
    age = int.Parse(ageString); 
    Console.WriteLine("Thank you"); 
} 

catch (Exception e) 
{   // Get the error message out of the exception 
    Console.WriteLine(e.Message); 
}


The catch now looks like a method call, with the Exception e being a parameter to the method. This is exactly how it works. Within the catch clause the value of e is set to the exception that was thrown by Parse. The Exception type has a property called Message which contains a string describing the error. If a user types in an invalid string the program above will write the text in the exception, which contains the message:
Input string was not in a correct format.
This message is obtained from the exception which was thrown. This is useful if the code inside the try block could throw several different kinds of exception, since it means that the message reflects what has actually happened. The Exception object also contains other properties which can be useful.

Programs can have multiple levels of try – catch, and the program will use the catch which matches the level of the code in the try block.

Sometimes there are things that your program must do irrespective of whether or not an exception is thrown. These actions include things like closing files, releasing resources and generally tidying up. However, we know that when an exception is thrown the statements in the catch clause are called, and the program never returns to the try part of the program. The code in the catch clause could return from the method it is running within or even throw an exception itself. In these situations any code following your try – catch construction would not get the chance to run.
Fortunately C# provides a solution to this problem by allowing you to add a finally clause to your try-catch construction. Statements inside the finally clause will run irrespective of whether or not the program in the try block throws an exception.

finally 
{ 
    // Code that is obeyed whether an exception 
    // is thrown or not 
}

C# contains a special construction to allow you to select one option from a number of them based on a particular value.
switch (selection) 
{ 
    case 1 : 
        handleCasement (); 
        break ; 
    case 2 : handleStandard ();
    break ;
    default : Console.WriteLine ( "Invalid number" ); 
    break; 
}

You can also fall through with c# switch statements. ie it continues to execute until it finds a break.
switch (command)
{
    case "casement" : 
    case "c" : 
        handleCasement (); 
        break ;
}

You can use switch commands with things like strings in c# too.


Streams and Files
Like lots of the objects that deal with input and output, this object is defined in the System.IO namespace.
You create a stream object just like you would create any other one, by using new. When the stream is created it can be passed the name of the file that is to be opened.
StreamWriter writer ; writer = new StreamWriter("test.txt");
Note that StreamWriter will overwrite the file test.txt, if it already exists.
Once the stream has been created it can be written to by calling the write methods it provides.
writer.WriteLine("hello world");
The above statement calls the WriteLine method on the stream to make it write the text “hello world” into the file test.txt.

When your program has finished writing to a stream it is very important that the stream is explicitly closed using the Close method:
writer.Close();
When the Close method is called the stream will write out any text to the file that is waiting to be written and disconnect the program from the file. Any further attempts to write to the stream will fail with an exception.


Reading from a file is very similar to writing, in that the program will create a stream to do the actual work. In this case the stream that is used is a StreamReader.
StreamReader reader = new StreamReader("Test.txt"); 
string line = reader.ReadLine(); 
Console.WriteLine (line);
reader.Close();

The above program connects a stream to the file Test.txt, reads the first line from the file, displays it on the screen and then close the stream. If the file can’t be found then the attempt to open it will fail and the program will throw an exception.
the StreamReader object provides a property called EndOfStream which a program can use to determine when the end of the file has been reached. When the property becomes true the end of the file has been reached.

StreamReader reader = new StreamReader("Test.txt"); 
while (reader.EndOfStream == false) 
{ 
    string line = reader.ReadLine(); 
    Console.WriteLine(line); 
} 
reader.Close();

If you want to use a file in a different folder (which is a good idea, as data files are hardly ever held in the same place as programs run from) you can add path information to a filename:
string path; 
path = @"c:\data\2009\November\sales.txt";

The backslash (\) characters in the string serve to separate the folders along the path to the file. Note that I have specified a string literal that doesn’t contain control characters (that is what the @ at the beginning of the literal means)

Enumeration and states
Enumerated sounds posh. But if you think of "enumerated" as just meaning "numbered" things get a bit easier. To understand what we are doing here we need to consider the problem which these types are intended to solve.
We know that if we want to hold an integer value we can use an int type. If we want to hold something which is either true or false we can use a bool. However, sometimes we want to hold a range of particular values or states.

Enumerated types are very useful when storing state information. States are not quite the same as other items such as the name of a customer or the balance of their account.
For example, if I am writing a program to play the game Battleships (where squares of the "sea" hold different types of craft which can be attacked) I may decide that a given square of the sea can have the following thing in it:
Empty sea
Attacked
Battleship
Cruiser
Submarine
Rowing boat

C# has a way in which we can create a type which has just a particular set of possible values. These types are called "enumerated types":
enum SeaState 
{ 
    EmptySea, Attacked, Battleship, Cruiser, Submarine, RowingBoat 
} ;
I have created a type called SeaState which can be used to hold the state of a particular part of the sea. It can only have the given values above, and must be managed solely in terms of these named enumerations. For example I must write:
SeaState openSea ; 
openSea = SeaState.EmptySea;
My variable openSea is only able to hold values which represent the state of the sea contents. Of course C# itself will actually represent these states as particular numeric values, but how these are managed is not a problem for me.
The new enum type can be created outside any class and creates a new type for use in any of my programs


Using Structure Types in Method Calls
A method can have parameters of structure type:
public void PrintAccount ( Account a ) 
{ 
    Console.WriteLine ( "Name: " + a.Name ); 
    Console.WriteLine ( "Address: " + a.Address ); 
    Console.WriteLine ( "Balance: " + a.Balance ); 
}
This method provides a quick way of printing out the contents of an account variable:
PrintAccount (RobsAccount);

It is also possible to create methods that return results which are of a structure type, for example we could create a ReadAccount method that reads an account and returns it.
Unlike classes, structures cannot inherit from other structures.

MVC

Controller Actions are the public methods of the controller classes. The public keyword exposes members of a class to other classes. If a member is declared private, another class cannot access it.
The Controller invokes classes based on the incoming http request which goes through the router middleware; converting the URL into arguments for the classes.
The directory structure matches the namespace structure in ASP. So, if you move a file from the folder called models, to the folder called entities, the namespace will change from: namespace OdeToFood.Models to: namespace OdeToFood.Entities
This means that some of the using statements will have to change as well. 

Routing

There are two types of routing, Convention based routing and Attribute based routing. Convetion based routing is defined in the startup.cs file by default. Attribute based routing is defined in the Controller files.

Convention based routing - templates tell MVC how to look at at a URL and obtain an action name (public method in a class) and a controller name (which is a class).
Attribute based routing - c# attributes which have been placed on the controller classes and methods of those classes provide metadata to ASP.NET which determines which class and method to call.
Convetiona and attribute routing can be combined. Attribute based routing generally works best for special case routes or actions which need some extra parameters.

IActionResult
It is common to derive your classes from a base class provided by the MVC framework. This gives you access to inherited methods. These derived classes typically use the IActionResult interface. An IActionResult is a formal way to encapsulate the decision of the controller. eg> It ihas decided to return content, but it could also return HTML,JSON or XML.
The controller decides what to do next and then the MVC framework works out how to render it. This higher level of abstraction is preferred over the controller deciding what to do and then doing the action as well. eg: when middleware or some other component pushes HTML out.


ASP.NET core 
This is a web framework

Dependency injection
Dependency Injection (DI) means that IoC is done without the object intervention, usually by a framework component that passes constructor parameters and set properties.
What is a dependency? When we use another object to perform a certain task, we are creating a dependency on that object. That object might use other objects, too, so you are implicitly depending on those other objects, and they too might depend on other objects to do their work, and so on.

Inversion of control container
http://joelabrahamsson.com/inversion-of-control-an-introduction-with-examples-in-net/

Inversion of control is often explained in comparison to procedural programming. In procedural programming, code x which uses other code y, knows exactly which method, belonging to which class, is being used. 
Inversion of Control (IoC) means that objects do not create other objects on which they rely to do their work. Instead, they get the objects that they need from an outside source.

What Is the Difference Between an Entity and a Service?
Entity-An object which has a unique identity in the domain model of the application
Service -An object which performs a distinct part of the application functionality

c# lambda expressions
A lambda expression describes a pattern. From mathematics, the lambda calculus describes the world in patterns. In C# a lambda is a function that uses clear and short syntax.
x => x + 1
To the left, we have arguments. The "x" is just a name—we can use any valid name. The result is on the right.
We pass lambda expressions as arguments, for sorting or for searching.
The => operator can be read as "goes to." It is always used when declaring a lambda expression.
We can achieve the same thing with regular, non-lambda methods. But they make a language easier to use, more "expressive."
Lambda expressions are particularly helpful for writing LINQ query expressions.
To create a lambda expression, you specify input parameters (if any) on the left side of the lambda operator =>, and you put the expression or statement block on the other side. For example, the lambda expression x => x * x specifies a parameter that’s named x and returns the value of x squared.

Anonymous functions
These are functions which have no names.

SOLID Design principles
http://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/

SOLID is basically 5 principles, which will help to create a good software architecture. SOLID is an acronym of the following:

S is single responsibility principle (SRP)
O stands for open closed principle (OCP)
L Liskov substitution principle (LSP)
I interface segregation principle (ISP)
D Dependency injection principle (DIP)

Single responsibility principle (SRP)
According to SRP, one class should take responsibility for only one thing, so that changes in one class do not affect other classes. Every software module should have only one reason for a change to be made to it.
It does not mean that your classes should only contain one method or property. There may be many members as long as they relate to the single responsibility.

Open closed principle (OCP)
This means that a Class should be open for extension but closed for modification. In order to do this, you use inheritance rather than things like if statements in classes.
Here "Open for extension" means, we need to design our module/class in such a way that the new functionality can be added only when new requirements are generated. "Closed for modification" means we have already developed a class and it has gone through unit testing. 
Generally we can do this by referring to abstractions for dependencies, such as interfaces or abstract classes, rather than using concrete classes. Such interfaces can be fixed once developed so the classes that depend upon them can rely upon unchanging abstractions.
Functionality can be added by creating new classes that implement the interfaces.

Liskov substitution principle (LSP)
This principle states that a Child class should not break a Parent class’s type definition and behavior. The Liskov Substitution Principle (LSP) states that "you should be able to use any derived class instead of a parent class and have it behave in the same manner without modification".
It ensures that a derived class does not affect the behavior of the parent class, in other words that a derived class must be substitutable for its base class.
A father is a doctor whereas his son wants to become a cricketer. So here the son can't replace his father even though they both belong to the same family hierarchy.

Interface segregation principle (ISP)
This principle states that a class should not be forced to use an interface which is irrelevant to it. Instead of one fat interface many small interfaces are preferred based on groups of methods, each one serving one sub module.
An interface should be more closely related to the code which uses it than code which implements it. So the methods on the interface are defined by which methods the client code needs than which methods the class implements. So clients should not be forced to depend upon interfaces that they don't use.
The larger the interface, the more likely it includes methods that not all implementers can do.
An interface is defined as a syntactical contract that all the classes inheriting the interface should follow. The interface defines the 'what' part of the syntactical contract and the deriving classes define the 'how' part of the syntactical contract.
https://www.tutorialspoint.com/csharp/csharp_interfaces.htm
Interfaces define properties, methods, and events, which are the members of the interface. Interfaces contain only the declaration of the members. It is the responsibility of the deriving class to define the members. It often helps in providing a standard structure which the deriving classes would follow.

Dependency inversion principle (DIP)
This principle tells you not to write any tightly coupled code because that is a nightmare to maintain when the application grows bigger. If a class depends on another class, then we need to change one class if something changes in that dependent class. We should always try to write loosely coupled classes which avoid this problem.
There are 3 types to DI, Constructor injection, Property injection and method injection.
The Dependency Inversion Principle (DIP) states that high-level modules/classes should not depend upon low-level modules/classes. Both should depend upon abstractions. Secondly, abstractions should not depend upon details. Details should depend upon abstractions.
High-level modules/classes implement business rules or logic in a system (application). Low-level modules/classes deal with more detailed operations, in other words they may deal with writing information to databases or passing messages to the operating system or services.
A high-level module/class which has dependency on low-level modules/classes and knows a lot about the other classes it interacts with is said to be tightly coupled. When a class knows explicitly about the design and implementation of another class, it raises the risk that changes to one class will break the other class.

http://joelabrahamsson.com/inversion-of-control-an-introduction-with-examples-in-net/

http://www.c-sharpcorner.com/UploadFile/damubetha/solid-principles-in-C-Sharp/
https://app.pluralsight.com/library/courses/aspdotnet-core-fundamentals/discussion

Relational Database
A relational database is a digital database whose organization is based on the relational model of data.

Relational model
The relational model organizes data into one or more tables (or "relations") of columns and rows, with a unique key identifying each row. The rows represent instances of that type of entity (such as "Lee" or "chair") and the columns representing values attributed to that instance (such as address or price).
The standard user and application program interface to a relational database is the structured query language (SQL).
A relational database is a set of tables containing data fitted into predefined categories. Each table (which is sometimes called a relation) contains one or more data categories in columns. Each row contains a unique instance of data for the categories defined by the columns. For example, a typical business order entry database would include a table that described a customer with columns for name, address, phone number, and so forth. Another table would describe an order: product, customer, date, sales price, and so forth. A user of the database could obtain a view of the database that fitted the user's needs. For example, a branch office manager might like a view or report on all customers that had bought products after a certain date. 

Language-Integrated Query(LINQ)
LINQ is set of extensions to the .Net Framework 3.5 which can be used for relational databases. LINQ applies the principles of object-oriented programming to relational data. It provides a unified programming model for querying data from different types of data sources, and extends data capabilities directly into the C# and Visual Basic languages. It defines a common syntax and a programming model to query different types of data using a common language.

Entity model vs viewModel
A database stores specific pieces of information eg Name, Address
Somewhere else in the app, there may be a view which requires the information from the database and also additional information (such as all the possible names which the database can store).
There are two ways of dealing with this:
1. Entity model - an entity is an object which you use to persist (store) information in the database. The EF stores the information and only the information in the database.
2. View model, also called a Data Transfer Object (DTO) - object which carries information from the controller into the view. It contains everything which a view will need to render the html. This might require more information than is in the database. The DTO can hand information to the EF in order to save it in the database.

ConfigurationBuilder
In ASP.NET Core, it is possible to read settings from different sources like XML, JSON and INI files.
The configuration API provides a way of configuring an app based on a list of name-value pairs which can be read at runtime from multiple sources. The name-value pairs can be grouped into a multi-level hierarchy. 
If you wish to leverage JSON files for your configuration, just add the Microsoft.Extensions.Configuration.Json NuGet package.

c# properties

A property is a member that provides a flexible mechanism to read, write, or compute the value of a private field. Properties can be used as if they are public data members, but they are actually special methods called accessors. This enables data to be accessed easily and still helps promote the safety and flexibility of methods.
Properties overview
Properties enable a class to expose a public way of getting and setting values, while hiding implementation or verification code.
A get property accessor is used to return the property value, and a set property accessor is used to assign a new value. These accessors can have different access levels. For more information, see Restricting Accessor Accessibility.
The value keyword is used to define the value being assigned by the set accessor.
Properties can be read-write (they have both a get and a set accessor), read-only (they have a get accessor but no set accessor), or write-only (they have a set accessor, but no get accessor). Write-only properties are rare and are most commonly used to restrict access to sensitive data.